<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Selenium学习</title>
      <link href="/Zzhanp.github.io/2021/12/18/selenium-xue-xi/"/>
      <url>/Zzhanp.github.io/2021/12/18/selenium-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="操作浏览器"><a href="#操作浏览器" class="headerlink" title="操作浏览器"></a>操作浏览器</h3><ul><li>打开网站</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入webdriver模块</span><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token comment" spellcheck="true"># 打开浏览器，注意Chrome的C是大写</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 打开百度</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span></code></pre><ul><li>设置休眠</li></ul><pre class=" language-yacas"><code class="language-yacas">1.由于打开百度网址后，页面加载需要几秒钟，所以最好等到页面加载完成后再继续下一步操作2.导入time模块，time模块是Python自带的，所以无需下载3.设置等待时间，单位是秒（s）,时间值可以是小数也可以是整数time.sleep(3)</code></pre><ul><li>页面刷新</li></ul><pre class=" language-yacas"><code class="language-yacas">driver.refresh()</code></pre><ul><li>前进和后退</li></ul><pre class=" language-yacas"><code class="language-yacas">返回上一个页面driver.back()切换到下一页driver.forward()</code></pre><ul><li>设置窗口大小</li></ul><pre class=" language-yacas"><code class="language-yacas">设置窗口大小为540*960driver.set_window_size(540, 960)将浏览器窗口最大化driver.maximize_window()</code></pre><ul><li>截屏</li></ul><pre class=" language-yacas"><code class="language-yacas">driver.get_screenshot_as_file("路径")</code></pre><ul><li>退出</li></ul><p>两种方式：close和quit</p><pre class=" language-yacas"><code class="language-yacas">1.close用于关闭当前窗口，当打开的窗口较多时，就可以用close关闭部分窗口。2.quit用于结束进程，关闭所有的窗口3.最后结束测试，要用quit。quit可以回收c盘的临时文件。</code></pre><h3 id="八种元素定位方法"><a href="#八种元素定位方法" class="headerlink" title="八种元素定位方法"></a>八种元素定位方法</h3><ul><li>find_element_by_id()</li></ul><p>通过id定位</p><pre class=" language-yacas"><code class="language-yacas">如百度搜索框：<input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off">通过id定位即driver.find_element_by_id("kw")</code></pre><ul><li>find_element_by_name()</li></ul><p>通过name属性定位：</p><pre class=" language-yacas"><code class="language-yacas">如百度搜索框：<input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off">通过name定位即driver.find_element_by_name("wd")</code></pre><ul><li>find_element_by_class_name()</li></ul><p>通过class属性定位：</p><pre class=" language-yacas"><code class="language-yacas">如百度搜索框：<input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off">通过id定位即driver.find_element_by_class_name("s_ipt")</code></pre><ul><li>find_element_by_tag_name()</li></ul><p>通过tag便签定位：</p><pre class=" language-yacas"><code class="language-yacas">如百度搜索框：<input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off">tag标签即input通过id定位即driver.find_element_by_tag_name("input")</code></pre><p><strong>在一个页面中，相同的标签有很多，所以一般不用标签来定位。</strong></p><ul><li>find_element_by_link_text()</li></ul><p>通过link定位：</p><pre class=" language-yacas"><code class="language-yacas"><a href="https://edu.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-edu')">班级</a>通过link定位即driver.find_element_by_link_text("班级")</code></pre><ul><li>find_element_by_partial_link_text()</li></ul><p>有时候一个超链接它的字符串可能比较长，如果输入全称的话，会显示很长，这时候可以用一模糊匹配方式，截取其中一部分字符串就可以了。</p><ul><li>find_element_by_xpath()</li></ul><p>通过xpath地址定位，具体下面详解。</p><ul><li>find_element_by_css_selector()</li></ul><p>通过css定位</p><h3 id="xpath定位"><a href="#xpath定位" class="headerlink" title="xpath定位"></a>xpath定位</h3><p>定义：</p><blockquote><p>XPath即为XML路径语言，它是一种用来确定<a href="http://baike.baidu.com/view/63.htm" target="_blank" rel="noopener">XML1</a>（<a href="http://baike.baidu.com/view/5286041.htm" target="_blank" rel="noopener">标准通用标记语言3</a>的子集）文档中某部分位置的语言。</p></blockquote><h4 id="属性定位"><a href="#属性定位" class="headerlink" title="属性定位"></a>属性定位</h4><p>xpath可以通过元素的id、name、class这些属性定位，还拿百度搜索框举例：</p><pre class=" language-yacas"><code class="language-yacas">如百度搜索框：<input type="text" class="s_ipt" name="wd" id="kw" maxlength="100" autocomplete="off">用xpath通过id属性定位：driver.find_element_by_xpath("//*[@id='kw']")用xpath通过name属性定位：driver.find_element_by_xpath("//*[@name='wd']")用xpath通过class属性定位：driver.find_element_by_xpath("//*[@class='s_ipt']")</code></pre><p>其他属性：</p><pre class=" language-yacas"><code class="language-yacas">用xpath通过其他属性定位：driver.find_element_by_xpath("//*[@autocomplete='off']")</code></pre><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><p>如果一个元素，它的属性不是很明显，无法直接定位到，这时候我们可以先找它<strong>父元素</strong>。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_kw_wrap<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg s_ipt_wr new-pmd quickdelete-wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>soutu-btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_ipt<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wd<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kw<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>off<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c-icon quickdelete c-color-gray2<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>清空<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>quickdelete-line<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>soutu-hover-tip<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>按图片搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><pre class=" language-yacas"><code class="language-yacas">通过父元素来定位：driver.find_element_by_xpath("//span[@id='s_kw_wrap']/input")</code></pre><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>xpath还有一个比较强的功能，是可以多个属性逻辑运算的，可以支持与（and）、或（or）、非（not）</p><pre class=" language-yacas"><code class="language-yacas">driver.find_element_by_xpath("//*[@id='kw' and @autocomplete='off']")</code></pre><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><pre class=" language-yacas"><code class="language-yacas">xpath模糊匹配功能driver.find_element_by_xpath("//*[contains(text(),'hao123')]")xpath模糊匹配某个属性driver.find_element_by_xpath("//*[contains(@id,'kw')]")xpath模糊匹配以什么开头driver.find_element_by_xpath("//*[starts-with(@id,'s_kw_')]")xpath模糊匹配以什么结尾driver.find_element_by_xpath("//*[ends-with(@id,'kw_wrap')]")</code></pre><h3 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h3><ul><li>css用#表示id属性，如：#kw</li><li>css用.表示class属性，如：.s_ipt</li><li>css直接用标签名称，无任何标识符，如：input</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_kw_wrap<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg s_ipt_wr new-pmd quickdelete-wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>soutu-btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>s_ipt<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wd<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kw<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>off<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c-icon quickdelete c-color-gray2<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>清空<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>quickdelete-line<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>soutu-hover-tip<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>按图片搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre><pre class=" language-yacas"><code class="language-yacas">css通过id属性定位driver.find_element_by_css_selector("#kw")css通过class属性定位driver.find_element_by_css_selector(".s_ipt")css通过标签属性定位driver.find_element_by_css_selector("input")css通过name属性定位driver.find_element_by_css_selector("[name='wd']")css通过autocomplete属性定位driver.find_element_by_css_selector("[autocomplete='off']")css通过type属性定位driver.find_element_by_css_selector("[type='text']")</code></pre><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>css也可以通过标签与属性的组合来定位元素</p><pre class=" language-yacas"><code class="language-yacas">driver.find_element_by_css_selector("input:contains('kw')")driver.find_element_by_css_selector("input.s_ipt")driver.find_element_by_css_selector("input#kw")</code></pre><h4 id="层级-1"><a href="#层级-1" class="headerlink" title="层级"></a>层级</h4><pre class=" language-yacas"><code class="language-yacas">先找到id为form的form标签，再往下找span，再往下找inputdriver.find_element_by_css_selector("form#form>span>input")driver.find_element_by_css_selector("form.fm>span>input")driver.find_element_by_css_selector("input#kw")</code></pre><h3 id="封装登录"><a href="#封装登录" class="headerlink" title="封装登录"></a>封装登录</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Firefox<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 调用登录，这里要传入driver</span>    login<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token string">"youruser"</span><span class="token punctuation">,</span> <span class="token string">"yourpsw"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello  yoyo!"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 调用退出</span>    logout<span class="token punctuation">(</span>driver<span class="token punctuation">)</span></code></pre><h3 id="键盘和鼠标事件"><a href="#键盘和鼠标事件" class="headerlink" title="键盘和鼠标事件"></a>键盘和鼠标事件</h3><h4 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h4><ul><li>点击：click()</li><li>清空输入框：clear()</li><li>输入字符串：send_keys()</li></ul><h4 id="submit提交表单"><a href="#submit提交表单" class="headerlink" title="submit提交表单"></a>submit提交表单</h4><pre class=" language-yacas"><code class="language-yacas">submit模拟enter键提交表单driver.find_element_by_id("kw").submit()</code></pre><h4 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h4><p><strong>模拟键盘的操作需要先导入键盘模块：from selenium.webdriver.common.keys import Keys</strong></p><pre class=" language-yacas"><code class="language-yacas">键盘F1到F12：send_keys(Keys.F1) 把F1改成对应的快捷键回车：send_keys(Keys.ENTER)空格：send_keys(Keys.SPACE)删除：send_keys(Keys.BACK_SPACE)复制Ctrl+C：send_keys(Keys.CONTROL,'c') 粘贴Ctrl+V：send_keys(Keys.CONTROL,'v') 全选Ctrl+A：send_keys(Keys.CONTROL,'a') 剪切Ctrl+X：send_keys(Keys.CONTROL,'x') 制表键Tab:  send_keys(Keys.TAB) </code></pre><h4 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h4><p>在 WebDriver 中，与鼠标操作相关的方法都封装在 ActionChains 类中。ActionChains 类提供了鼠标操作的常用方法：</p><ul><li>perform()：执行ActionChains类中存储的所有行为</li><li>context_click()：右击</li><li>double_click()：双击</li><li>drag_and_drop()：拖动</li><li>move_to_element：鼠标悬停</li></ul><h5 id="鼠标悬停"><a href="#鼠标悬停" class="headerlink" title="鼠标悬停"></a>鼠标悬停</h5><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 引入 ActionChains 类</span><span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver <span class="token keyword">import</span> ActionChainsdriver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.cn"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定位到要悬停的元素</span>above <span class="token operator">=</span> driver<span class="token punctuation">.</span>find_element_by_link_text<span class="token punctuation">(</span><span class="token string">"设置"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对定位到的元素执行鼠标悬停操作</span>ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>move_to_element<span class="token punctuation">(</span>above<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><p>获取当前窗口句柄：</p><pre class=" language-yacas"><code class="language-yacas">driver.current_window_handle</code></pre><p>获取所有句柄：</p><pre class=" language-yacas"><code class="language-yacas">driver.window_handles</code></pre><p>切换句柄：</p><ul><li>法一</li></ul><ol><li><p>循环判断是否与首页句柄相等</p></li><li><p>如果不等，说明是新页面的句柄</p></li><li><p>获取的新页面句柄后，可以切换到新打开的页面上</p></li><li><p>打印新页面的title,看是否切换成功</p></li></ol><ul><li>法二</li></ul><p>直接获取all_h这个list数据里面第二个hand的值：all_h[1]</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><blockquote><p>Iframe标记又叫浮动帧标记，可以用它将一个HTML文档嵌入在一个HTML中显示。它和Frame标记的最大区别是在网页中嵌入的<iframe></iframe>所包含的内容与整个页面是一个整体，而<frame>&lt; /Frame&gt;所包含的内容是一个独立的个体，是可以独立显示的。另外，应用Iframe还可以在同一个页面中多次显示同一内容，而不必重复这段内容的代码。</p></blockquote><p>切换iframe：</p><ul><li>把定位器切换到iframe</li><li>用switch_to_frame方法切换，可以用id、name定位切换</li><li>若没有id、name属性，则需要先定位ifame</li></ul><p>释放iframe：</p><p>当iframe上的操作完后，想重新回到主页面上操作元素，这时候，就可以用switch_to_default_content()方法返回到主页面</p><p>推荐写法：</p><p><strong>driver.switch_to.frame()</strong></p><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p>以百度搜索为例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>NR<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>每页显示 10 条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>每页显示 20 条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>每页显示 50 条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h4 id="二次定位"><a href="#二次定位" class="headerlink" title="二次定位"></a>二次定位</h4><p>思路：先定位select框，再定位select里的选项</p><pre class=" language-python"><code class="language-python">s<span class="token punctuation">.</span>driver<span class="token punctuation">.</span>find_element_by_id<span class="token punctuation">(</span><span class="token string">"nr"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>find_element_by_xpath<span class="token punctuation">(</span><span class="token string">"//option[@value='50']"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h4><pre class=" language-yacas"><code class="language-yacas">xpath定位driver.find_element_by_xpath("//*[@id='nr']/option[2]").click()</code></pre><h4 id="Select模块"><a href="#Select模块" class="headerlink" title="Select模块"></a>Select模块</h4><ul><li>导入select方法：from selenium.webdriver.support.select import Select</li></ul><h5 id="通过index定位"><a href="#通过index定位" class="headerlink" title="通过index定位"></a>通过index定位</h5><pre class=" language-yacas"><code class="language-yacas">s = driver.find_element_by_id("nr")Select(s).select_by_index(2)</code></pre><h5 id="通过value定位"><a href="#通过value定位" class="headerlink" title="通过value定位"></a>通过value定位</h5><pre class=" language-yacas"><code class="language-yacas">s = driver.find_element_by_id("nr")Select(s).select_by_value("20")</code></pre><h5 id="通过text定位"><a href="#通过text定位" class="headerlink" title="通过text定位"></a>通过text定位</h5><pre><code>s = driver.find_element_by_id(&quot;nr&quot;)Select(s).select_by_visible_text(&quot;每页显示50条&quot;)</code></pre><h5 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h5><pre class=" language-yacas"><code class="language-yacas">deselect_all()          ：取消所有选项deselect_by_index()     ：取消对应index选项deselect_by_value()      ：取消对应value选项deselect_by_visible_text() ：取消对应文本选项first_selected_option()  ：返回第一个选项all_selected_options()   ：返回所有的选项</code></pre><h3 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h3><ul><li>基本操作<ul><li>text：返回alert、confirm、prompt中的文字信息</li><li>accept()：接受现有警告框</li><li>dismiss()：解散 现有警告框</li><li>send_keys()：在警告框中输入文本</li></ul></li></ul><p><strong>获取警告框：alert = driver.switch_to_alert()</strong></p><h3 id="调用JavaScript"><a href="#调用JavaScript" class="headerlink" title="调用JavaScript"></a>调用JavaScript</h3><p>滚动条是无法直接用定位工具来定位的。selenium里面也没有直接的方法去控制滚动条，selenium提供了一个操作js的方法：<strong>execute_script()</strong>，可以直接执行js脚本。</p><h4 id="纵向滚动条"><a href="#纵向滚动条" class="headerlink" title="纵向滚动条"></a>纵向滚动条</h4><pre class=" language-yacas"><code class="language-yacas">1.滚动条回到顶部：js="var q=document.getElementById('id').scrollTop=0"driver.execute_script(js）2.滚动条拉到底部js="var q=document.documentElement.scrollTop=10000"driver.execute_script(js)</code></pre><h4 id="横向滚动条"><a href="#横向滚动条" class="headerlink" title="横向滚动条"></a>横向滚动条</h4><pre class=" language-yacas"><code class="language-yacas">scrollTo(x, y）js = "window.scrollTo(100,400);"driver.execute_script(js)window.scrollTo()方法用于设置浏览器窗口滚动条的水平位置和垂直位置。第一个参数表示水平的左边距，第二个参数表示垂直的上边距</code></pre><p>谷歌浏览器：</p><pre class=" language-yacas"><code class="language-yacas">js = "var q=document.body.scrollTop=0"driver.execute_script(js)</code></pre><h4 id="输入内容"><a href="#输入内容" class="headerlink" title="输入内容"></a>输入内容</h4><p>JavaScript还可以在页面中的textarea文本框中输入内容：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">98%</span></span><span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>textarea<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span></code></pre><p>虽然可以通过id定位到元素，但是不能通过send_keys在文本框中输入文本信息，在这种情况下，可以借助JavaScript代码输入文本信息。</p><pre class=" language-yacas"><code class="language-yacas">text = "input text"js = "document.getElementById('id').value='" + text + "';"driver.execute_script(js)首先，定义要输入的内容text，然后将text与JavaScript代码通过+进行拼接，最后，通过execute_script()执行代码。</code></pre><h3 id="单选框和复选框"><a href="#单选框和复选框" class="headerlink" title="单选框和复选框"></a>单选框和复选框</h3><p><strong>单选框是圆的，复选框是方的</strong></p><h4 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>单选：性别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>male<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>boy<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>girl<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>  </code></pre><pre class=" language-yacas"><code class="language-yacas">直接点击即可driver.find_element_by_id("boy").click()time.sleep(10)driver.find_element_by_id("girl").click()</code></pre><h4 id="复选"><a href="#复选" class="headerlink" title="复选"></a>复选</h4><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;label for="c1">checkbox1&lt;/label> --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>selenium<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;label for="c2">checkbox2&lt;/label> --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>python<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;label for="c3">checkbox3&lt;/label> --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c3<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>appium<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><pre class=" language-yacas"><code class="language-yacas">若单选则直接定位即可，若全部勾选，可以用到定位一组元素。checkboxs = driver.find_elements_by_xpath(".//*[@type='checkbox']")for i in checkboxs:    i.click()    time.sleep(2)注意：find_elements是不能直接点击的，所以需要先获取到所有的checkbox对象，然后通过for循环去一个个点击操作。</code></pre><h4 id="判断是否选中"><a href="#判断是否选中" class="headerlink" title="判断是否选中"></a>判断是否选中</h4><p>当它是没选中的时候，我去点击下；当它已经是选中状态，就不点击。达到这个目的可以使用<strong>is_selected()</strong>，选中返回True，未选中返回False。</p><pre class=" language-yacas"><code class="language-yacas">s = driver.find_element_by_id("boy").is_selected()print(s)</code></pre><h3 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h3><h4 id="切换iframe"><a href="#切换iframe" class="headerlink" title="切换iframe"></a>切换iframe</h4><ol><li>定位iframe</li><li>切换iframe：<strong>driver.switch_to.frame()</strong></li><li>send_keys输入</li></ol><h4 id="JS输入中文"><a href="#JS输入中文" class="headerlink" title="JS输入中文"></a>JS输入中文</h4><ol><li>定位iframe</li><li>js输入中文</li></ol><pre class=" language-yacas"><code class="language-yacas">body = "这里是js发的正文内容"js = 'document.getElementById("Editor_Edit_EditorBody_ifr").contentWindow.document.body.innerHTML="%s"' % bodydriver.execute_script(js)</code></pre><h3 id="js处理日历控件"><a href="#js处理日历控件" class="headerlink" title="js处理日历控件"></a>js处理日历控件</h3><ol><li>用js去掉readonly属性</li><li>然后直接输入日期文本内容</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>train_date<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>inp-txt<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>leftTicketDTO.train_date<span class="token punctuation">"</span></span> <span class="token attr-name">autocomplete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>off<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">readonly</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readonly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h4 id="js去掉readonly属性："><a href="#js去掉readonly属性：" class="headerlink" title="js去掉readonly属性："></a>js去掉readonly属性：</h4><ol><li>先定位到元素</li><li>用removeAttribute(“readonly”)删除属性</li><li>出发日元素id为：train_date，对应js代码为：’document.getElementById(“train_date”).removeAttribute(“readonly”);’</li></ol><h4 id="输入日期"><a href="#输入日期" class="headerlink" title="输入日期"></a>输入日期</h4><ol><li>输入日期前，一定要先清空文本</li><li>输入日期两种方法<ul><li>send_keys法</li><li>js输入日期，直接改掉输入框元素的value值即可</li></ul></li></ol><pre class=" language-yacas"><code class="language-yacas">js_value = 'document.getElementById("train_date").value = "2021-12-18"'driver.execute_script(js_value)</code></pre><h3 id="js处理内嵌div滚动条"><a href="#js处理内嵌div滚动条" class="headerlink" title="js处理内嵌div滚动条"></a>js处理内嵌div滚动条</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是一个内嵌的div滚动条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yoyoketang<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yoyo<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scroll<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是一个内嵌div:民国年间，九大家族镇守长沙，被称为“九门提督”。这九门势力庞大，外八行的无人不知，无人不晓，几乎所有冥器，流出长沙必然经过其中一家。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位"></a>通过id定位</h4><ul><li>纵向滚动</li></ul><pre class=" language-yacas"><code class="language-yacas">js1 = 'document.getElementById("yoyoketang").scrollTop=10000'driver.execute_script(js1)time.sleep(5)js1 = 'document.getElementById("yoyoketang").scrollTop=0'driver.execute_script(js1)</code></pre><ul><li>横向滚动</li></ul><pre class=" language-yacas"><code class="language-yacas">js1 = 'document.getElementById("yoyoketang").scrollLeft=10000'driver.execute_script(js1)time.sleep(5)js1 = 'document.getElementById("yoyoketang").scrollLeft=0'driver.execute_script(js1)</code></pre><h4 id="通过class定位"><a href="#通过class定位" class="headerlink" title="通过class定位"></a>通过class定位</h4><p>js用class定位，返回的是一个list对象，这里取第一个即可</p><pre class=" language-yacas"><code class="language-yacas">js2 = 'document.getElementsByClassName("scroll")[0].scrollTop=10000'driver.execute_script(js2)</code></pre><h3 id="查看selenium-API"><a href="#查看selenium-API" class="headerlink" title="查看selenium API"></a>查看selenium API</h3><blockquote><p> pydoc是Python自带的模块，主要用于从python模块中自动生成文档，这些文档可以基于文本呈现的、也可以生成WEB 页面的，还可以在服务器上以浏览器的方式呈现！</p></blockquote><p>例：查看open函数的功能和语法</p><pre class=" language-yacas"><code class="language-yacas">python -m pydoc open</code></pre><p>查看selenium：</p><ol><li>python -m pydoc -p 6666<ul><li>-p：代表在本机上启动服务</li><li>6666：端口号</li></ul></li><li>浏览器查看文档</li></ol><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211218225759819.png" alt="image-20211218225759819"></p><h3 id="table定位"><a href="#table定位" class="headerlink" title="table定位"></a>table定位</h3><p>table特征：</p><pre class=" language-yacas"><code class="language-yacas">1.table页面查看源码一般有这几个明显的标签：table、tr、th、td2.<table>标示一个表格3.<tr>标示这个表格中间的一个行4.</th> 定义表头单元格5.</td> 定义单元格标签，一组<td>标签将将建立一个单元格，<td>标签必须放在<tr>标签内</code></pre><p>用xpath定位即可</p><h3 id="js处理多窗口"><a href="#js处理多窗口" class="headerlink" title="js处理多窗口"></a>js处理多窗口</h3><p>链接在新窗口打开，原因是元素属性target=”_blank”</p><blockquote><p><a target="value">：</a></p><ol><li>_blank：在新窗口中打开被链接文档。</li><li>_self：在被点击时的同一框架中打开被链接文档（默认）。</li><li>_parent： 在父框架中打开被链接文档。</li><li>_top： 在窗口主体中打开被链接文档。</li></ol></blockquote><p>处理方法：用js去掉_blank属性</p><ol><li>定位该元素</li><li>修改target值为空</li></ol><pre class=" language-yacas"><code class="language-yacas">js = 'document.getElementsByClassName("mnav")[0].target="";'driver.execute_script(js)</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unittest学习</title>
      <link href="/Zzhanp.github.io/2021/11/29/unittest-xue-xi/"/>
      <url>/Zzhanp.github.io/2021/11/29/unittest-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="unittest学习"><a href="#unittest学习" class="headerlink" title="unittest学习"></a>unittest学习</h1><h2 id="测试用例——testcase"><a href="#测试用例——testcase" class="headerlink" title="测试用例——testcase"></a>测试用例——testcase</h2><p>通过继承TestCase类来构建单元测试用例，语法如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 测试类名<span class="token punctuation">(</span>unitest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    测试用例</code></pre><p>一个测试用例可以通过定义一个函数完成，将执行测试的代码封装到函数内，最后通过TestCase类中的断言来判断测试是否通过，常用的断言方法有：</p><pre class=" language-yacas"><code class="language-yacas">assertEqual(预期值, 实际值)：当两者相等的时候测试通过assertNotEqual(预期值, 实际值)：当两者不相等的时候测试通过assertTrue(表达式)：当表达式为真的时候测试通过assertFalse(表达式)：当表达式为假的时候测试通过assertIs(a, b)：a is bassertIsNot(a, b)：a is not bassertIn(a, b)：a in b</code></pre><ul><li>每个测试用例需以“test”打头的方法命名，这个命名规定告知测试运行器哪些方法代表需要测试。</li></ul><h2 id="测试固件——testfixture"><a href="#测试固件——testfixture" class="headerlink" title="测试固件——testfixture"></a>测试固件——testfixture</h2><p>对一个测试用例环境的搭建和销毁，是一个fixture，通过覆盖 TestCase的setUp()和tearDown()方法来实现。这个有什么用呢？比如说在这个测试用例中需要访问数据库，那么可以在setUp() 中建立数据库连接以及进行一些初始化，在tearDown()中清除在数据库中产生的数据，然后关闭连接。注意tearDown的过程很重要，要为以后的 TestCase留下一个干净的环境。</p><p>如定义URL：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">logintest</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">setUp</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>url <span class="token operator">=</span> <span class="token string">"xxxx"</span></code></pre><h2 id="测试套件——testsuite"><a href="#测试套件——testsuite" class="headerlink" title="测试套件——testsuite"></a>测试套件——testsuite</h2><p>多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite。unittest模块提供了TestSuite类来生成测试套件，使用该类的构造函数可以生成一个测试套件的实例，该类提供了addTest来把每个测试用例加入到测试套件中</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>unittest是python自带的一个单元测试框架，类似于java的junit，基本结构是类似的。基本用法如下：</p><ol><li><p>用import unittest导入unittest模块</p></li><li><p>定义一个继承自unittest.TestCase的测试用例类，如class xxx(unittest.TestCase):</p></li><li><p>定义setUp和tearDown，这两个方法与junit相同，即如果定义了则会在每个测试case执行前先执行setUp方法，执行完毕后执行tearDown方法。</p></li><li><p>定义测试用例，名字以test开头，unittest会自动将test开头的方法放入测试用例集中。</p></li><li><p>一个测试用例应该只测试一个方面，测试目的和测试内容应很明确。主要是调用assertEqual、assertRaises等断言方法判断程序执行结果和预期值是否相符。</p></li><li><p>调用unittest.main()启动测试</p></li><li><p>如果测试未通过，则会显示e，并给出具体的错误（此处为程序问题导致）。如果测试失败则显示为f，测试通过为.，如有多个testcase，则结果依次显示。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试的艺术</title>
      <link href="/Zzhanp.github.io/2021/11/27/ruan-jian-ce-shi-de-yi-zhu/"/>
      <url>/Zzhanp.github.io/2021/11/27/ruan-jian-ce-shi-de-yi-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试的艺术"><a href="#软件测试的艺术" class="headerlink" title="软件测试的艺术"></a>软件测试的艺术</h1><h2 id="1-一次自评价测试"><a href="#1-一次自评价测试" class="headerlink" title="1. 一次自评价测试"></a>1. 一次自评价测试</h2><p>一个小案例：</p><pre class=" language-yacas"><code class="language-yacas">这个程序从一个输入对话框中读取三个整数值，这三个整数值代表了三角形三条边的长度。程序显示提示信息，指出该三角形是何种三角形：不规则三角形、等腰三角形还是等边三角形。</code></pre><p>测试用例：</p><pre class=" language-yacas"><code class="language-yacas">自己想的：1.输入为空2.输入一个整数值3.输入三个整数值4.输入四个整数值5.输入三个带小数值6.输入三个字母等字符类7.输入三个能构成等腰三角形的整数值8.输入三个能构成等边三角形的整数值9.输入三个能构成不规则三角形的整数值10.输入三个不能构成三角形的整数值补充：1.三个测试用例，代表有效的等腰三角形，从而可以测试到两等边的所有三种可能情况2.某边的长度等于03.某边的长度为负数4.第十条的扩展：一边等于另外两边之和、两个整数之和小于第三个5.三边长度皆为0</code></pre><h2 id="2-软件测试的心理学和经济学"><a href="#2-软件测试的心理学和经济学" class="headerlink" title="2. 软件测试的心理学和经济学"></a>2. 软件测试的心理学和经济学</h2><ul><li>对所有的可能情况都设计测试用例是不切合实际的。</li></ul><h3 id="2-1-软件测试的心理学"><a href="#2-1-软件测试的心理学" class="headerlink" title="2.1 软件测试的心理学"></a>2.1 软件测试的心理学</h3><p>测试是为发现错误而执行程序的过程，而不是理解为验证软件不存在错误的过程。</p><h2 id="4-测试用例的设计"><a href="#4-测试用例的设计" class="headerlink" title="4. 测试用例的设计"></a>4. 测试用例的设计</h2><ul><li>在所有可能的测试用例中，哪个子集最有可能发现最多的错误？</li></ul><h3 id="4-2-黑盒测试"><a href="#4-2-黑盒测试" class="headerlink" title="4.2 黑盒测试"></a>4.2 黑盒测试</h3><h4 id="4-2-1-等价划分"><a href="#4-2-1-等价划分" class="headerlink" title="4.2.1 等价划分"></a>4.2.1 等价划分</h4><ul><li>严格控制测试用例的增加，减少为达到“合理测试”的某些既定目标而必须设计的其他测试用例的数量。</li></ul><blockquote><p>每个测试用例都必须体现尽可能多的不同的输入情况，以使最大限度地减少测试所需地全部用例地数量。</p></blockquote><ul><li>它覆盖了大部分其他可能的测试用例。</li></ul><blockquote><p>尽量将程序输入范围进行划分，将其划分为有限数量的等价类。</p></blockquote><h5 id="4-2-1-1-确定等价类"><a href="#4-2-1-1-确定等价类" class="headerlink" title="4.2.1.1 确定等价类"></a>4.2.1.1 确定等价类</h5><p>选取每一个输入条件并将其划分为两个或更多的组。</p><ul><li>输入条件</li><li>有效等价类</li><li>无效等价类</li></ul><p>划分原则：</p><pre class=" language-yacas"><code class="language-yacas">1.如果输入条件规定了一个取值范围（例如，“数量可以是从1到999”)，那么就应确定出一个有效等价类（1<数量<999），以及两个无效等价类（数量<1，数量>999）。2.如果输入条件规定了取值的个数（例如，“汽车可登记一至六名车主”），那么就应确定出一个有效等价类和两个无效等价类（没有车主，或车主多于六个）。3.如果输入条件规定了一个输入值的集合，而且有理由认为程序会对每个值进行不同处理（例如，“交通工具的类型必须是公共汽车、卡车、出租车、火车或摩托车”），那么就应为每个输入值确定一个有效等价类和一个无效等价类（例如，“拖车”）。4.如果存在输人条件规定了“必须是”的情况，例如标识符的第一个字符必须是字母”，那么就应确定一个有效等价类(首宇符是宇母）和一个无效等价类（首字符不是字母）。</code></pre><h5 id="4-2-1-2-生成测试用例"><a href="#4-2-1-2-生成测试用例" class="headerlink" title="4.2.1.2 生成测试用例"></a>4.2.1.2 生成测试用例</h5><ol><li>为每一个等价类设置一个不同地编号。</li><li>编写新的测试用例，<strong>尽可能多地覆盖那些尚未被覆盖地有效等价类</strong>，直到所有的有效等价类都被测试用例覆盖。</li><li>编写新的测试用例，<strong>覆盖一个且仅一个尚未被覆盖的无效等价类</strong>，直到所有的无效等价类都被覆盖。</li></ol><p><strong>用单个测试用例覆盖无效等价类</strong></p><h4 id="4-2-3-边界值分析"><a href="#4-2-3-边界值分析" class="headerlink" title="4.2.3 边界值分析"></a>4.2.3 边界值分析</h4><ul><li>考虑边界条件的测试用例具有<strong>更高的测试回报率</strong></li><li>输入和输出等价类中恰好处于边界、或超过边界、或在边界以下的状态</li></ul><p><strong>常见的边界值：</strong></p><ol><li>对16-bit 的整数而言 32767 和 -32768 是边界</li><li>屏幕上光标在最左上、最右下位置</li><li>报表的第一行和最后一行</li><li>数组元素的第一个和最后一个</li><li>循环的第 0 次、第 1 次和倒数第 2 次、最后一次</li><li>通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。</li><li>相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、 最短/最长、 空/满等情况下。</li></ol><p><strong>基于边界值分析法选择测试用例的原则：</strong></p><ol><li>如果输入条件规定了值的范围,则应取<strong>刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值</strong>作为测试输入数据。例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。</li><li>如果输入条件规定了值的个数,则用<strong>最大个数,最小个数,比最小个数少一,比最大个数多一的数</strong>作为测试数据。比如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。</li><li>将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。<br>例如，某程序的规格说明要求计算出”每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。再如一程序属于情报检索系统，要求每次”最少显示1条、最多显示4条情报摘要”，这时我们应考虑的测试用例包括1和4，还应包括0和5等。</li><li>如果程序的规格说明给出的输入域或输出域是<strong>有序集合</strong>,则应选取集合的<strong>第一个元素和最后一个元素</strong>作为测试用例。</li><li>如果程序中使用了一个内部数据结构,则应当选择这个<strong>内部数据结构的边界上的值</strong>作为测试用例。</li><li>分析规格说明,找出其它可能的边界条件。</li></ol><h4 id="4-2-4-因果图"><a href="#4-2-4-因果图" class="headerlink" title="4.2.4 因果图"></a>4.2.4 因果图</h4><p>因果图有助于用一个系统的方法选择出高效的测试用例集。它还有一个额外的好处，就是可以指出规格说明的不完整性和不明确之处。</p><p>步骤：</p><ol><li>将规格说明分解为可执行的片段。</li><li>确定规格说明中的因果关系。</li><li>分析规格说明的语义内容，将其转换为连接因果关系的布尔图。</li><li>给图加上注解符号，说明由于语法或环境的限制而不能联系起来的“因”和“果”。</li><li>通过仔细地跟踪图中的状态变化情况，将因果图转换成一个有限项地判定表。</li><li>将判定表中的列转换成测试用例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo d时报错</title>
      <link href="/Zzhanp.github.io/2021/11/27/hexo-d-shi-bao-cuo/"/>
      <url>/Zzhanp.github.io/2021/11/27/hexo-d-shi-bao-cuo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-d时报错"><a href="#hexo-d时报错" class="headerlink" title="hexo d时报错"></a>hexo d时报错</h1><p>今天在上传文章时出现了报错，具体如下：</p><pre class=" language-yacas"><code class="language-yacas">TypeError [ERR_INVALID_ARG_TYPE]: The "mode" argument must be integer. Receivedan instance of Object</code></pre><p>上网查了一下，是node版本太高导致，所以解决方案为切换node为低版本。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python批量修改文件名</title>
      <link href="/Zzhanp.github.io/2021/11/26/python-pi-liang-xiu-gai-wen-jian-ming/"/>
      <url>/Zzhanp.github.io/2021/11/26/python-pi-liang-xiu-gai-wen-jian-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Python批量修改文件名"><a href="#Python批量修改文件名" class="headerlink" title="Python批量修改文件名"></a>Python批量修改文件名</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>现有一批文件，以数字开头，想要将他们改为test+原文件名的格式。如图：</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211126225138401.png" alt="image-20211126225138401"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然会用Python，那么就用Python来解决这个问题吧~</p><p>首先回顾一下Python的os库</p><h3 id="OS库"><a href="#OS库" class="headerlink" title="OS库"></a>OS库</h3><table><thead><tr><th>方法和变量</th><th>用途</th></tr></thead><tbody><tr><td>os.getcwd()</td><td>获取当前工作目录，即当前python脚本工作的目录路径</td></tr><tr><td>os.chdir(“dirname”)</td><td>改变当前脚本工作目录；相当于shell下cd</td></tr><tr><td>os.curdir</td><td>返回当前目录: (‘.’)</td></tr><tr><td>os.pardir</td><td>获取当前目录的父目录字符串名：(‘..’)</td></tr><tr><td>os.makedirs(‘dir1/dir2’)</td><td>可生成多层递归目录</td></tr><tr><td>os.removedirs(‘dirname1’)</td><td>递归删除空目录（要小心）</td></tr><tr><td>os.mkdir(‘dirname’)</td><td>生成单级目录</td></tr><tr><td>os.rmdir(‘dirname’)</td><td>删除单级空目录，若目录不为空则无法删除并报错</td></tr><tr><td>os.listdir(‘dirname’)</td><td>列出指定目录下的所有文件和子目录，包括隐藏文件</td></tr><tr><td>os.remove(‘filename’)</td><td>删除一个文件</td></tr><tr><td>os.rename(“oldname”,”new”)</td><td>重命名文件/目录</td></tr><tr><td>os.stat(‘path/filename’)</td><td>获取文件/目录信息</td></tr><tr><td>os.path.abspath(path)</td><td>返回path规范化的绝对路径</td></tr><tr><td>os.path.split(path)</td><td>将path分割成目录和文件名二元组返回</td></tr><tr><td>os.path.dirname(path)</td><td>返回path的目录。其实就是<code>os.path.split(path)</code>的第一个元素</td></tr><tr><td>os.path.basename(path)</td><td>返回path最后的文件名。如果path以<code>／</code>或<code>\</code>结尾，那么就会返回空值。</td></tr><tr><td>os.path.exists(path或者file)</td><td>如果path存在，返回True；如果path不存在，返回False</td></tr><tr><td>os.path.isabs(path)</td><td>如果path是绝对路径，返回True</td></tr><tr><td>os.path.isfile(path)</td><td>如果path是一个存在的文件，返回True。否则返回False</td></tr><tr><td>os.path.isdir(path)</td><td>如果path是一个存在的目录，则返回True。否则返回False</td></tr><tr><td>os.path.join(path1[, path2[, …]])</td><td>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</td></tr><tr><td>os.path.getatime(path)</td><td>返回path所指向的文件或者目录的最后存取时间</td></tr><tr><td>os.path.getmtime(path)</td><td>返回path所指向的文件或者目录的最后修改时间</td></tr><tr><td>os.path.getsize(filename)</td><td>返回文件包含的字符数量</td></tr></tbody></table><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先找出所有文件，然后再找出以0x开头的文件，将这些文件改成test+原文件名的形式。</p><p>分析一下要达成上述目标，需要使用的方法：</p><p>os.listdir(path)：这个操作能够列出当前路径下所有文件及子目录</p><p>os.path.isfile(path)：这个操作用来找出文件，去掉文件夹</p><p>old_name ：如果是文件，首先存取它的原文件名</p><p>new_name：新文件名为test + oldname</p><p>os.rename(“oldname”, “newname”)：重命名</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> ospath <span class="token operator">=</span> <span class="token string">'E:/my code/python/test/codetest'</span><span class="token comment" spellcheck="true"># 获取所有文件及子目录</span><span class="token keyword">for</span> file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 判断是否为文件</span>    <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 判断文件名是否以0开头</span>        <span class="token keyword">if</span> file<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>            newname <span class="token operator">=</span> <span class="token string">"test"</span> <span class="token operator">+</span> file            os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>file<span class="token punctuation">,</span> newname<span class="token punctuation">)</span></code></pre><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><pre class=" language-yacas"><code class="language-yacas">FileNotFoundError: [WinError 2] 系统找不到指定的文件。: '01_get.py' -> 'test01_get.py'</code></pre><ul><li>尝试一：文件路径后加/</li></ul><pre class=" language-python"><code class="language-python">path <span class="token operator">=</span> <span class="token string">'E:/my code/python/test/codetest'</span></code></pre><p>不行</p><ul><li>尝试二：rename()中路径写完整，采用os.path.join()方法，给文件名加上路径</li></ul><pre class=" language-yacas"><code class="language-yacas">os.rename(os.path.join(path,file), os.path.join(path,newname))</code></pre><p>成功~</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实两次尝试都是有必要的，从报错来看，系统找不到指定的文件。</p><p>第二次尝试：</p><pre class=" language-yacas"><code class="language-yacas">os.rename(file, newname)中，file为'01_get.py'，newname为'test01_get.py'如果没有指定路径的话，系统无处可找这两个文件，所以要改为os.rename(os.path.join(path,file), os.path.join(path,newname))</code></pre><p>第一次尝试：</p><pre class=" language-yacas"><code class="language-yacas">如果路径后没有加/，有时python会将该l</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点</title>
      <link href="/Zzhanp.github.io/2021/11/26/ji-suan-ji-wang-luo-zhi-shi-dian/"/>
      <url>/Zzhanp.github.io/2021/11/26/ji-suan-ji-wang-luo-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读新摄影笔记</title>
      <link href="/Zzhanp.github.io/2021/11/10/xin-she-ying-bi-ji/"/>
      <url>/Zzhanp.github.io/2021/11/10/xin-she-ying-bi-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摄影学习</title>
      <link href="/Zzhanp.github.io/2021/11/07/she-ying-xue-xi/"/>
      <url>/Zzhanp.github.io/2021/11/07/she-ying-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="摄影学习"><a href="#摄影学习" class="headerlink" title="摄影学习"></a>摄影学习</h1><h2 id="成像原理与相机结构"><a href="#成像原理与相机结构" class="headerlink" title="成像原理与相机结构"></a>成像原理与相机结构</h2><p>相机重心置于左手上，大拇指和食指操作变焦环。</p><h2 id="机身与镜头"><a href="#机身与镜头" class="headerlink" title="机身与镜头"></a>机身与镜头</h2><h3 id="机身"><a href="#机身" class="headerlink" title="机身"></a>机身</h3><p>卡口环、快门键、热靴（加装外置闪光灯、麦克风等）、取景器、屏幕、肩屏、脚架螺口</p><h3 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h3><pre class=" language-yacas"><code class="language-yacas">CANON ZOOM LENS EF-S 18-135mm 1:3.5-5.6 IS </code></pre><p>CANON：品牌</p><p>ZOOM：变焦</p><p>EF-S：镜头的卡口类型，EF卡口，S：非全画幅</p><p>18-135mm：最短焦距-最长焦距，称为焦距段</p><p>1:3.5-5.6：最大光圈</p><p>IS ：光学防抖</p><pre class=" language-yacas"><code class="language-yacas">VR NIKON DX AF-S</code></pre><p>VR：光学防抖</p><p>DX ：装置在尼康的非全画幅相机上</p><p>AF-S：自动对焦，S：宁静的</p><h3 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h3><p>焦：焦平面，距：镜头的中心点到焦平面的距离</p><p>焦距越长，望远能力越强（视角越窄）。</p><p>长焦/望远镜头</p><h4 id="以焦距为标准的镜头分类"><a href="#以焦距为标准的镜头分类" class="headerlink" title="以焦距为标准的镜头分类"></a>以焦距为标准的镜头分类</h4><h5 id="按焦距是否可变：变焦镜头、定焦镜头"><a href="#按焦距是否可变：变焦镜头、定焦镜头" class="headerlink" title="按焦距是否可变：变焦镜头、定焦镜头"></a>按焦距是否可变：变焦镜头、定焦镜头</h5><p>景别：远景、全景、中景、近景、特写</p><p>变焦镜头在同一个地点能够实现不同的景别</p><p>定焦镜头：移动摄影师位置</p><h5 id="按焦距长短：广角、标准、中焦、长焦"><a href="#按焦距长短：广角、标准、中焦、长焦" class="headerlink" title="按焦距长短：广角、标准、中焦、长焦"></a>按焦距长短：广角、标准、中焦、长焦</h5><p><strong>广角镜头</strong>：<strong>焦距小于28mm</strong></p><p><em>超广角：24mm以下焦距：<strong>适合拍摄大场景、建筑、风景，也可以在狭小空间内不拍摄，能把小空间拍摄的很大</strong></em></p><p><em>标准广角：24~28mm焦距：<strong>主要用来拍摄风景</strong></em></p><p><em>特点：景别很大，在不是很远的位置就能实现很大的景别，视角开阔，变形</em>更为显著</p><p><em>一般广角：35mm，被称为大师的焦距，也被称为人文眼</em></p><p><strong>标准镜头</strong>：焦距50mm左右</p><p>特点：<strong>自然逼真贴切，贴近人眼</strong></p><p><strong>中焦镜头（肖像镜头）</strong>：85-135mm</p><p>特点：背景更虚，若用广角、标准镜头拍摄肖像，需要靠得很近。<strong>不提倡使用焦距短的镜头拍摄小景别</strong>。</p><p><strong>长焦镜头</strong>（望远镜头）：大于135mm</p><p>特点：背景很虚，空间感不强。</p><h5 id="按特殊用途：微距镜头、移轴镜头"><a href="#按特殊用途：微距镜头、移轴镜头" class="headerlink" title="按特殊用途：微距镜头、移轴镜头"></a>按特殊用途：微距镜头、移轴镜头</h5><p>微距镜头：微缩景观，放大细节</p><p>移轴镜头：矫正建筑倾斜</p><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>用来控制光线透过镜头，进入机身内感光面的光量的装置。</p><p>光圈的值越大，进光越少。光圈的值越小，进光越多。</p><p>1:3.5-5.6：非恒定光圈镜头，随着焦距的改变，最大光圈有所缩小。</p><p>1:1.8：恒定光圈镜头</p><h2 id="快门、光圈、各种曝光模式"><a href="#快门、光圈、各种曝光模式" class="headerlink" title="快门、光圈、各种曝光模式"></a>快门、光圈、各种曝光模式</h2><h3 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h3><p>指摄影的过程中允许进入镜头照在感光媒体上的光量。“曝光”可经由光圈，快门和感光媒体的感光度的组合来控制。</p><h4 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h4><p>快门速度：曝光时间</p><p>通过控制进光时间来控制进光量，进光时间长短决定了画面的亮度</p><p>糊了：拍摄物体在感光媒介上的成像发生了偏移，记录了一个轨迹的过程</p><p>拍摄物体的速度越快，使用的快门速度应该越高，曝光时间更短。</p><p><strong>快门速度高，运动的瞬间被记录。快门速度低，运动的过程被记录。</strong></p><p>光圈值越小，画面中清晰的范围越多。</p><h4 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h4><p>景物纵向上清晰的深度。</p><p><strong>光圈越大，景深越小，背景虚的更明显。</strong></p><p>利用大光圈实现景物模糊，<strong>净化构图。</strong></p><p><strong>光圈优先</strong>：手动定义光圈的大小，然后利用相机的测光获取响应的快门值。</p><p>人像摄影中经常以大光圈实现小景深。</p><p><strong>突出主体、深化主题使用大光圈</strong>。</p><p>快门优先：S或Tv</p><p>拍摄运动瞬间时，使用高速快门。</p><h2 id="像素、白平衡、相对感光度"><a href="#像素、白平衡、相对感光度" class="headerlink" title="像素、白平衡、相对感光度"></a>像素、白平衡、相对感光度</h2><p>画幅的意义：</p><p>画幅越大，广角又是越明显。</p><p>RAW：丢失的信息很少，几乎没有压缩，后期。</p><h3 id="相对感光度"><a href="#相对感光度" class="headerlink" title="相对感光度"></a>相对感光度</h3><p>胶片的感光度：底片对光线的敏感程度。</p><p>相对感光度：提速快门，方便抓拍高速物体。</p><p>只要光线允许，尽量使用最低的ISO。</p><p>如果光线不允许，可以高一些。</p><h3 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h3><p>拍摄晚霞，自动模式天空很蓝，可以使用阴天模式，晚霞则会变红。</p><h2 id="景深原理与对焦"><a href="#景深原理与对焦" class="headerlink" title="景深原理与对焦"></a>景深原理与对焦</h2><p>景深：景物清晰的深度</p><p>光圈越大，画面中清晰范围越小</p><p>光圈越小，背景越清晰。</p><p>长焦镜头：背景极虚的小景深效果。</p><h3 id="景深三要素"><a href="#景深三要素" class="headerlink" title="景深三要素"></a>景深三要素</h3><ul><li><p>景深与光圈成反比</p></li><li><p>景深与焦距成反比</p></li><li><p>景深与拍摄距离（对焦距离）成正比</p></li></ul><h3 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h3><h4 id="对焦方式的选择"><a href="#对焦方式的选择" class="headerlink" title="对焦方式的选择"></a>对焦方式的选择</h4><p>单次对焦：拍摄静止物体或运动幅度较小的物体。</p><p>自动选择：自动判断</p><p>人工智能伺服对焦：连续测距</p><h4 id="对焦点模式的选择"><a href="#对焦点模式的选择" class="headerlink" title="对焦点模式的选择"></a>对焦点模式的选择</h4><p>单点：自己自由选择</p><p>动态区域：当选择的焦点没对上焦时，会自动选择周围一个点进行对焦。</p><h4 id="对焦点的选择"><a href="#对焦点的选择" class="headerlink" title="对焦点的选择"></a>对焦点的选择</h4><h2 id="曝光补偿与手动模式"><a href="#曝光补偿与手动模式" class="headerlink" title="曝光补偿与手动模式"></a>曝光补偿与手动模式</h2><h3 id="曝光-1"><a href="#曝光-1" class="headerlink" title="曝光"></a>曝光</h3><p>曝光不足、曝光过度、曝光正常</p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/Zzhanp.github.io/2021/11/06/python-ji-chu/"/>
      <url>/Zzhanp.github.io/2021/11/06/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数：十六进制用0x前缀，如0xff00</p><p>浮点数：小数</p><p>字符串：</p><p>转义字符\：</p><pre class=" language-python"><code class="language-python"><span class="token string">'I\'m \"OK\"!'</span></code></pre><pre class=" language-python"><code class="language-python">\n：换行      \t：制表符   \\：表示\</code></pre><p>若字符串里有很多字符需要转义，可以使用r’’表示’’内部的字符串默认不转义</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\\\t\\'</span><span class="token punctuation">)</span>\       \<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token string">'\\\t\\'</span><span class="token punctuation">)</span>\\\t\\</code></pre><p>多行内容： ‘’’…’’’</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">'''line1... line2... line3'''</span><span class="token punctuation">)</span>line1line2line3</code></pre><p>布尔值：True和False，可以用and、or和not运算</p><p>判断数据类型：type或isinstance(a,str)</p><p>s.isalnum() 所有字符都是数字或者字母，为真返回 Ture，否则返回 False。</p><p>s.isalpha()  所有字符都是字母，为真返回 Ture，否则返回 False。</p><p>s.isdigit()   所有字符都是数字，为真返回 Ture，否则返回 False。</p><p>s.islower()  所有字符都是小写，为真返回 Ture，否则返回 False。</p><p>s.isupper()  所有字符都是大写，为真返回 Ture，否则返回 False。</p><p>s.istitle()    所有单词都是首字母大写，为真返回 Ture，否则返回 False。</p><p>s.isspace()  所有字符都是空白字符，为真返回 Ture，否则返回 False</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>幂运算&gt;正负号&gt;算术操作符&gt;比较操作符&gt;逻辑操作符&gt;</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名必须使大小写英文、数字和_的组合，且不能用数字开头。</p><p>这种变量本身类型不固定的语言称为动态语言。</p><p>a = ‘ABC’：</p><ol><li>在内存中创建一个’ABC’字符串</li><li>在内存中创建一个名为a的变量。并把它指向’ABC’</li></ol><p>b = a ：把变量b指向变量a所指向的数据</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>习惯上用全部大写的变量名表示常量</p><pre class=" language-python"><code class="language-python">PI <span class="token operator">=</span> <span class="token number">3.14159265359</span></code></pre><p>/：除，结果为浮点数</p><p>//：地板除，结果为整数    %：取余数</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>中国GB2312编码</p><p>Unicode：将所有语言统一到一套编码</p><p>UTF-8：把Unicode编码转化为“可变长编码”，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923923787018816/0" alt="rw-file-utf-8"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>python3中，字符串是以Unicode编码。</p><p>ord()：获取字符的整数表示</p><p>chr()：将编码转换为对应的字符</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token number">65</span><span class="token operator">>></span><span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">'中'</span><span class="token punctuation">)</span><span class="token number">20013</span><span class="token operator">>></span><span class="token operator">></span> chr<span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token string">'B'</span><span class="token operator">>></span><span class="token operator">></span> chr<span class="token punctuation">(</span><span class="token number">25991</span><span class="token punctuation">)</span><span class="token string">'文'</span></code></pre><p>python字符串类型是str，在内存中以Unicode表示。若要在网络上传输，或者保存到磁盘，就需要把str转换为以字节为单位的bytes。</p><p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p><pre class=" language-python"><code class="language-python">x <span class="token operator">=</span> <span class="token string">'ABC'</span>x <span class="token operator">=</span> b<span class="token string">'ABC'</span></code></pre><p>前者是str，后者是bytes，bytes的每个字符只占用一个字节。</p><p>str通过encode()方法可以编码为指定的bytes，如</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'ABC'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span>b<span class="token string">'ABC'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'中文'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>b<span class="token string">'\xe4\xb8\xad\xe6\x96\x87'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'中文'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>UnicodeEncodeError<span class="token punctuation">:</span> <span class="token string">'ascii'</span> codec can't encode characters <span class="token keyword">in</span> position <span class="token number">0</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> ordinal <span class="token operator">not</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span></code></pre><p>在bytes中，无法显示为ASCII字符的字节，用\x##表示</p><p>如果从网络或磁盘中读取了字节流，读到的数据是bytes，用decode()方法将bytes变为str。</p><p>len()：计算str包含多少个字符，如果换成bytes，len()就计算字节数：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>b<span class="token string">'ABC'</span><span class="token punctuation">)</span><span class="token number">3</span><span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>b<span class="token string">'\xe4\xb8\xad\xe6\x96\x87'</span><span class="token punctuation">)</span><span class="token number">6</span><span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span><span class="token string">'中文'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">6</span></code></pre><p>为避免乱码问</p><p>题，应始终坚持使用UTF-8编码对str和Unicode进行转换。</p><p>当Python源代码中包含中文时，在保存源代码时，务必指定保存为UTF-8编码。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3        //告诉Linux/OS X系统，这是一个Python可执行程序</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-       //告诉Python解释器，按照UTF-8读取源代码</span></code></pre><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串。</p><p>%运算符：格式化字符串</p><p>%s：字符串替换       %d：整数替换      %f：浮点数           %x：十六进制整数</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Hello, %s'</span> <span class="token operator">%</span> <span class="token string">'world'</span><span class="token string">'Hello, world'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Hi, %s, you have $%d.'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token string">'Hi, Michael, you have $1000000.'</span></code></pre><p>有几个%?占位符，后面就跟几个变量或值。</p><p>字符串里%是一个普通字符：使用%%转义表示一个%</p><h4 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h4><p>格式：”{} {}”.format(“hello”, “world”)</p><p>位置可以不指定位置，按默认顺序，也可以设置指定位置。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token string">"{} {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 不设置指定位置，按默认顺序</span><span class="token string">'hello world'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"{0} {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 设置指定位置</span><span class="token string">'hello world'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"{1} {0} {1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 设置指定位置</span><span class="token string">'world hello world'</span></code></pre><p>也可以设置参数：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：{name}, 地址 {url}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> url<span class="token operator">=</span><span class="token string">"www.runoob.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过字典设置参数</span>site <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"www.runoob.com"</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：{name}, 地址 {url}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">**</span>site<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过列表索引设置参数</span>my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'菜鸟教程'</span><span class="token punctuation">,</span> <span class="token string">'www.runoob.com'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网站名：{0[0]}, 地址 {0[1]}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>my_list<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># "0" 是必须的</span></code></pre><p>在 <strong>:</strong> 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> table <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Google'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Runoob'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> number <span class="token keyword">in</span> table<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0:10} ==> {1:10d}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Google     <span class="token operator">==</span><span class="token operator">></span>          <span class="token number">1</span>Runoob     <span class="token operator">==</span><span class="token operator">></span>          <span class="token number">2</span>Taobao     <span class="token operator">==</span><span class="token operator">></span>          <span class="token number">3</span></code></pre><h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><p>冒号后跟格式</p><p>填充：字符串总共8位，填充星号，245右对齐</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"{:*>8}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"245"</span><span class="token punctuation">)</span><span class="token string">'*****245'</span></code></pre><table><thead><tr><th style="text-align:left">数字</th><th style="text-align:left">格式</th><th style="text-align:left">输出</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:.2f}</td><td style="text-align:left">3.14</td><td style="text-align:left">保留小数点后两位</td></tr><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:+.2f}</td><td style="text-align:left">+3.14</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">{:+.2f}</td><td style="text-align:left">-1.00</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">2.71828</td><td style="text-align:left">{:.0f}</td><td style="text-align:left">3</td><td style="text-align:left">不带小数</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:0&gt;2d}</td><td style="text-align:left">05</td><td style="text-align:left">数字补零 (填充左边, 宽度为2)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">5xxx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">10xx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">1000000</td><td style="text-align:left">{:,}</td><td style="text-align:left">1,000,000</td><td style="text-align:left">以逗号分隔的数字格式</td></tr><tr><td style="text-align:left">0.25</td><td style="text-align:left">{:.2%}</td><td style="text-align:left">25.00%</td><td style="text-align:left">百分比格式</td></tr><tr><td style="text-align:left">1000000000</td><td style="text-align:left">{:.2e}</td><td style="text-align:left">1.00e+09</td><td style="text-align:left">指数记法</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&gt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">右对齐 (默认, 宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&lt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">左对齐 (宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:^10d}</td><td style="text-align:left">13</td><td style="text-align:left">中间对齐 (宽度为10)</td></tr></tbody></table><h3 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h3><h4 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h4><p>截取字符串：使用方括号来截取字符串：变量[头下标:尾下标]，规则为“前闭后开”</p><p>字符串连接：使用+</p><p>字符串运算符：</p><table><thead><tr><th>+</th><th>字符串连接</th><th>&gt;&gt;&gt;a + b ‘HelloPython’</th></tr></thead><tbody><tr><td>*</td><td>重复输出字符串</td><td>&gt;&gt;&gt;a * 2 ‘HelloHello’</td></tr><tr><td>[]</td><td>通过索引获取字符串中字符</td><td>&gt;&gt;&gt;a[1] ‘e’</td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分</td><td>&gt;&gt;&gt;a[1:4] ‘ell’</td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td>&gt;&gt;&gt;”H” in a True</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td>&gt;&gt;&gt;”M” not in a True</td></tr></tbody></table><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>list的索引从0开始，要取最后一个元素，可以用-1做索引。</p><p>创建列表：list1 = [1,2,3]</p><p>添加列表项：append()：</p><p>插入到指定位置：insert(1,’Jack’)</p><p>删除末尾元素：pop()</p><p>删除指定位置：pop(i)或del list[i]，pop有返回值</p><p>删除指定元素：remove(元素)</p><p>替换元素：直接赋值给对应的索引位置：classmates[1] = ‘Sarah’</p><h5 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h5><p>Python包含以下函数:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-cmp.html" target="_blank" rel="noopener">cmp(list1, list2)</a> 比较两个列表的元素</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-len.html" target="_blank" rel="noopener">len(list)</a> 列表元素个数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-max.html" target="_blank" rel="noopener">max(list)</a> 返回列表元素最大值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-min.html" target="_blank" rel="noopener">min(list)</a> 返回列表元素最小值</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-list.html" target="_blank" rel="noopener">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-append.html" target="_blank" rel="noopener">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><a href="https://www.runoob.com/python/att-list-count.html" target="_blank" rel="noopener">list.count(obj)</a> 统计某个元素在列表中出现的次数</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-extend.html" target="_blank" rel="noopener">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><a href="https://www.runoob.com/python/att-list-index.html" target="_blank" rel="noopener">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-insert.html" target="_blank" rel="noopener">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-pop.html" target="_blank" rel="noopener">list.pop([index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且<strong>返回该元素的值</strong></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-remove.html" target="_blank" rel="noopener">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong><a href="https://www.runoob.com/python/att-list-reverse.html" target="_blank" rel="noopener">list.reverse()</a> 反向列表中元素</strong></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><a href="https://www.runoob.com/python/att-list-sort.html" target="_blank" rel="noopener">list.sort(cmp=None, key=None, reverse=False)</a> 对原列表进行排序</strong></td></tr></tbody></table><p><strong>列表可以比较大小</strong></p><p>list.index(i,strat,end):可以指定起始和结束位置</p><p>逆序排序：list.sort(reverse=True)</p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>有序，tuple一旦初始化就不能修改。</p><p>创建元组：tup1 = (1,2,3)</p><p><strong>定义只有1个元素的tuple，如果：tup = (1)，则定义的不是tuple，是<code>1</code>这个数。这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</strong></p><p><strong>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：tup1 = (50,)</strong></p><p>元组不可修改或删除，但是可以连接和删除：</p><p>tup3 = tup1 + tup2</p><p>del tup</p><p>Python元组包含了以下内置函数</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-tuple-cmp.html" target="_blank" rel="noopener">cmp(tuple1, tuple2)</a> 比较两个元组元素。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-tuple-len.html" target="_blank" rel="noopener">len(tuple)</a> 计算元组元素个数。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-tuple-max.html" target="_blank" rel="noopener">max(tuple)</a> 返回元组中元素最大值。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-tuple-min.html" target="_blank" rel="noopener">min(tuple)</a> 返回元组中元素最小值。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-tuple-tuple.html" target="_blank" rel="noopener">tuple(seq)</a> 将列表转换为元组。</td></tr></tbody></table><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>elif：else if的缩写</p><p>多个条件判断：and、or</p><p>and、or的优先级低于&gt;、&lt;</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>input()返回的数据类型是str，若想跟整数比较，必须先将str转换为整数：s =int(input(“请输入”))</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for-x-in-…"><a href="#for-x-in-…" class="headerlink" title="for x in …"></a>for x in …</h4><p>range()：可创建一个整数列表</p><p>语法：range(start,stop[,step])</p><pre class=" language-yacas"><code class="language-yacas">start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</code></pre><h5 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h5><p>for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p><strong>无限循环：while 1:</strong></p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>提前结束循环</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>跳过本次循环，开始下一次循环</p><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass不做任何事情，一般用作占位语句</p><h3 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h3><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>格式：d = {key1 : value1, key2 : value2 }</p><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p><p>访问字典的值：dict[‘name’]</p><p>修改字典：</p><p>删除key：pop(key)</p><p>删除字典：del dict[‘name’]   删除键是’name’的条目</p><pre class=" language-python"><code class="language-python">dict<span class="token punctuation">[</span><span class="token string">'Age'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span> <span class="token comment" spellcheck="true"># 更新</span>dict<span class="token punctuation">[</span><span class="token string">'School'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"RUNOOB"</span> <span class="token comment" spellcheck="true"># 添加</span></code></pre><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><ol><li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。</li><li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。</li></ol><h5 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h5><p>Python字典包含了以下内置函数：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html" target="_blank" rel="noopener">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-len.html" target="_blank" rel="noopener">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-str.html" target="_blank" rel="noopener">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-type.html" target="_blank" rel="noopener">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-clear.html" target="_blank" rel="noopener">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-copy.html" target="_blank" rel="noopener">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-fromkeys.html" target="_blank" rel="noopener">dict.fromkeys(seq[, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-get.html" target="_blank" rel="noopener">dict.get(key, default=None)</a> 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html" target="_blank" rel="noopener">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-items.html" target="_blank" rel="noopener">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-keys.html" target="_blank" rel="noopener">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html" target="_blank" rel="noopener">dict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-update.html" target="_blank" rel="noopener">dict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-dictionary-values.html" target="_blank" rel="noopener">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/python/python-att-dictionary-pop.html" target="_blank" rel="noopener">pop(key[,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html" target="_blank" rel="noopener">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h5 id="dict和list对比"><a href="#dict和list对比" class="headerlink" title="dict和list对比"></a>dict和list对比</h5><p>dict：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢</li><li>需要占用大量的内存，内存浪费多</li></ol><p>list：</p><ol><li>查找和插入的时间随着元素的增加而增加</li><li>占用空间小，浪费内存很少</li></ol><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>无序和无重复元素的集合</p><p>重复元素在set中自动被过滤</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre><p>添加元素：add(key)</p><p>删除元素：remove(key)</p><p>两个set可以做数学意义上的交集、并集操作：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">&amp;</span> s2<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">|</span> s2<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span></code></pre><h3 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h3><p>不变：number、str、tuple、dict的key、set的key</p><p>变：list、dict、set</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>&#39;Abc&#39;</code>，但变量<code>a</code>最后仍是<code>&#39;abc&#39;</code>，应该怎么理解呢？</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Abc'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'abc'</span></code></pre><p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p><pre class=" language-ascii"><code class="language-ascii">┌───┐                  ┌───────┐│ a │─────────────────>│ 'abc' │└───┘                  └───────┘</code></pre><p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<strong><code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回</strong>，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p><pre class=" language-ascii"><code class="language-ascii">┌───┐                  ┌───────┐│ a │─────────────────>│ 'abc' │└───┘                  └───────┘┌───┐                  ┌───────┐│ b │─────────────────>│ 'Abc' │└───┘                  └───────┘</code></pre><h4 id="理解dict的不变"><a href="#理解dict的不变" class="headerlink" title="理解dict的不变"></a>理解dict的不变</h4><ol><li>list和tuple其实是用链表顺序存储的，也就是前一个元素中存储了下一个元素的位置，这样只要找到第一个元素的位置就可以顺藤摸瓜找到所有元素的位置，所以list的名字其实就是个指针，指向list的第一个元素的位置。list的插入和删除等可以直接用链表的方式进行，比如我要在第1个元素和第2个元素中间插入一个元素，那么直接在链表的最后面（我们假设这个list只有两个元素，那么也就是在第3个元素的位置上）插入这个元素，然后把第一个元素指针指向这个元素（第3个位置），然后再把新插入的元素的指针指向原来的第2个元素，这样插入操作就完成了。读取这个list的时候，先用list的名字（就是个指针，指向第1个元素的位置）找到第一个元素，然后用第1一个元素的指针找到第2个元素（位置3），然后用第2个元素的指针找到第3个元素（位置2），以此类推。所以list的顺序和内存中的实际顺序其实不一定完全对应。这种存储方式不会浪费内存，但查找起来特别费时间，因为要按照链表一个一个找下去，如果你的list特别大的话，那么要等好久才会找到结果。</li><li>dict则为了快速查找使用了一种特别的方法，哈希表。哈希表采用哈希函数从key计算得到一个数字（哈希函数有个特点：对于不同的key，有很大的概率得到的哈希值也不同），然后直接把value存储到这个数字所对应的地址上，比如key=’ABC’，value=10，经过哈希函数得到key对应的哈希值为123，那么就申请一个有1000个地址（从0到999）的内存，然后把10存放在地址为123的地方。类似的，对于key=’BCD’，value=20，得到key的哈希值为234，那么就把20存放在地址为234的地方。对于这样的表查找起来是非常方便的。只要给出key，计算得到哈希值，然后直接到对应的地址去找value就可以了。无论有几个元素，都可以直接找到value，无需遍历整个表。不过虽然dict查找速度快，但内存浪费严重，你看我们只存储了两个元素，都要申请一个长度为1000的内存。</li><li>现在你知道为啥key要用不可变对象了吧？因为不可变对象是常量，每次的哈希值算出来都是固定的，这样就不会出错。比如key=’ABC’，value=10，存储地址为123，假设我突发奇想，把key改成’BCD’，那么当查找’BCD’的value的时候就会去234的地址找，但那里啥也没有，这就乱套了。</li><li>你看我们上面有一句话：对于不同的key，有很大的概率得到的哈希值也不同。那么有很小的概率不同的key可以得到相同的哈希值了？没错，比如对于我们的例子来说，哈希值只有3位，那么只要元素个数超过1000，就一定会有至少两个key的哈希值相同（鸽笼原理），这种情况叫“冲突”，设计哈希表的时候要采取办法减少冲突，实在冲突了也要想办法补救。不过这是编译器的事情，况且对于初学者的我们来说碰到的冲突的概率基本等于零，就不用操心了。</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>数据类型转换：int()、float()、str()、bool()</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">functionname</span><span class="token punctuation">(</span> parameters <span class="token punctuation">)</span><span class="token punctuation">:</span>   function_suite   <span class="token keyword">return</span> <span class="token punctuation">[</span>expression<span class="token punctuation">]</span>       <span class="token operator">//</span>不带表达式的<span class="token keyword">return</span>相当于返回 None</code></pre><h4 id="导入函数"><a href="#导入函数" class="headerlink" title="导入函数"></a>导入函数</h4><p><code>from abstest import my_abs</code>来导入<code>my_abs()</code>函数，注意<code>abstest</code>是文件名</p><h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">nop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre><p>pass还可以用来做占位符</p><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>Python的函数返回多值其实就是返回一个tuple，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python使用lambda来创建匿名函数</p><p>语法：lambda [arg1 [,arg2,…..argn]]:expression</p><p>lambda x : 2 * x + 1</p><p>lambda x, y : x + y</p><p>作用：写一些脚本时，使用lambda可以省下定义函数过程。</p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>        s <span class="token operator">=</span> s <span class="token operator">*</span> x    <span class="token keyword">return</span> s</code></pre><p>注意：</p><p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p><p>二是如何设置默认参数。</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><pre class=" language-yacas"><code class="language-yacas">默认参数必须指向不变对象</code></pre><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul><li><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li><strong>可变类型：</strong>类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ChangeInt</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token operator">//</span>传不可变对象举例    a <span class="token operator">=</span> <span class="token number">10</span>b <span class="token operator">=</span> <span class="token number">2</span>ChangeInt<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span> b <span class="token comment" spellcheck="true"># 结果是 2</span></code></pre><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token operator">*</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>    sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> n <span class="token operator">*</span> n    <span class="token keyword">return</span> sum</code></pre><p>在函数内部，参数<code>numbers</code>接收到的是一个<strong>tuple</strong></p><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见</p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<strong>dict</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'age:'</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token string">'other:'</span><span class="token punctuation">,</span> kw<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'Beijing'</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Bob age<span class="token punctuation">:</span> <span class="token number">35</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Beijing'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token string">'M'</span><span class="token punctuation">,</span> job<span class="token operator">=</span><span class="token string">'Engineer'</span><span class="token punctuation">)</span>name<span class="token punctuation">:</span> Adam age<span class="token punctuation">:</span> <span class="token number">45</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'gender'</span><span class="token punctuation">:</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Engineer'</span><span class="token punctuation">}</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> extra <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Engineer'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> person<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token operator">**</span>extra<span class="token punctuation">)</span>name<span class="token punctuation">:</span> Jack age<span class="token punctuation">:</span> <span class="token number">24</span> other<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'Beijing'</span><span class="token punctuation">,</span> <span class="token string">'job'</span><span class="token punctuation">:</span> <span class="token string">'Engineer'</span><span class="token punctuation">}</span></code></pre><pre class=" language-yacas"><code class="language-yacas">**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra</code></pre><h4 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h4><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token punctuation">,</span> job<span class="token punctuation">)</span></code></pre><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><h4 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h4><p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">return</span> n <span class="token operator">*</span> fact<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>过滤器：filter(function,  迭代对象)</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">odd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> temp <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> show <span class="token operator">=</span> filter<span class="token punctuation">(</span>odd<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>show<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span></code></pre><p>结合lambda：filter(lambda x : x % 2, range(10))</p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>只写<code>[:]</code>就可以原样复制一个list</p><pre class=" language-yacas"><code class="language-yacas">注意list1 = list2[:]和list3 = list2的区别：前者只是复制值，后者相当于复制地址，当list2改变时，list1不变而list3会跟着改变。</code></pre><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在Python中，迭代是通过<code>for ... in</code>来完成的</p><p>默认情况下，<code>dict</code>迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要<strong>同时迭代key和value，可以用<code>for k, v in d.items()</code>。</strong></p><p>Python不是通过下标，如下面ch是字符串里的元素，不是下标。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> ch <span class="token keyword">in</span> <span class="token string">'ABC'</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ABC</code></pre><p>想通过下标迭代，可以使用</p><pre class=" language-python"><code class="language-python"> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>‘ABC’<span class="token punctuation">)</span>）</code></pre><p>要对<code>list</code>实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个<code>list</code>变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身。</p><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i<span class="token punctuation">,</span> value <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0</span> A<span class="token number">1</span> B<span class="token number">2</span> C</code></pre><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>格式：variable    =    [out_exp    for    out_exp    in    input_list    if    out_exp    ==    2]</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span></code></pre><p>列表生成式有<strong>返回值</strong></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><p>一、创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> g <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> g<span class="token operator">&lt;</span>generator object <span class="token operator">&lt;</span>genexpr<span class="token operator">></span> at <span class="token number">0x1022ef630</span><span class="token operator">></span></code></pre><p>打印generator的每一个元素：next()获得generator的下一个返回值</p><p>二、yield关键字，如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator函数。</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>enerator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向过程：顺序地调用不同的函数</p><p>特点：注重过程与步骤，不注重职责分工，如果需求复杂，代码会变得很复杂。</p><p>面向对象：职责明确</p><p>三大特性：</p><ul><li>封装：根据职责将属性和方法封装到一个抽象的类中</li><li>继承：实现代码的复用，相同的代码不需要重复的编写</li><li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类：</p><p>对一群具有相同特征或者行为的事物的一个统称，抽象的，不能直接使用。</p><p>特征被称为属性，行为被称为方法。</p><p>对象：</p><p>由类创建出来的一个具体存在，可以直接使用。</p><p>对象相当于用图纸制造的飞机。</p><p>由哪一个类创建出来的对象，就拥有哪一个类中定义的属性和方法。</p><p>关系：</p><ul><li><p>先有类，再有对象。</p></li><li><p>类只有一个，对象可以有很多个。</p></li><li>类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。</li></ul><h4 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h4><p>开发前需要确定需要包含哪些类。</p><p>设计类的三要素：</p><ul><li>类名：这类事物的名字，满足大驼峰命名法</li><li>属性：这类事物具有什么样的特征</li><li>方法：这类事物具有什么样的行为</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h5><p>使用dir传入标识符/数据，可以查看对象内的所有属性和方法</p><h5 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">:</span>    <span class="token keyword">def</span> 方法<span class="token number">1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> 参数列表<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#第一个参数必须是self</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> 方法<span class="token number">2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> 参数列表<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>   </code></pre><h5 id="输出对象属性"><a href="#输出对象属性" class="headerlink" title="输出对象属性"></a>输出对象属性</h5><p><strong>哪一个对象调用的方法，self就是哪一个对象的引用。</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">cat</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 爱吃鱼"</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#self是对象的引用</span>tom <span class="token operator">=</span> cat<span class="token punctuation">(</span><span class="token punctuation">)</span>tom<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"大懒猫"</span>tom<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果   大懒猫爱吃鱼</span></code></pre><p>在方法内部，可以通过self.访问对象的属性</p><h5 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h5><p>使用类名()创建对象时，会自动执行以下操作：</p><ul><li>为对象在内存中分配空间–创建对象</li><li>为对象的属性设置初始值–初始化方法(init)</li></ul><p>这个初始化方法就是<code>_init_</code>方法，是专门用来定义类具有哪些属性的方法。</p><p>使用类名（）创建对象时，会自动调用初始化方法。</p><h5 id="内部定义属性"><a href="#内部定义属性" class="headerlink" title="内部定义属性"></a>内部定义属性</h5><p>在<code>_init_</code>方法内部使用self.属性名 = 属性的初始值就可以定义属性</p><p>定义属性后，再使用类创建的对象，都会拥有该属性。</p><p>可以使用参数设置属性初始值：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>name <span class="token operator">=</span> new_name</code></pre><p>del关键字可以删除一个对象</p><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>比较两个对象的<strong>内存地址</strong>是否一致——是否是对同一个对象的引用</p><h4 id="is与-的区别"><a href="#is与-的区别" class="headerlink" title="is与==的区别"></a>is与==的区别</h4><p>is用于判断两个变量<strong>引用对象</strong>是否为同一个</p><p>==用于判断<strong>引用变量的值</strong>是否相等</p><h3 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h3><p>定义：在属性名或方法名前增加两个下划线。</p><p>私有属性和私有方法在外界不能够被直接访问。</p><p>在对象的方法内部，是可以访问对象的私有属性的。</p><p>子类对象不能直接访问父类的私有属性，但可以通过父类的公有方法间接访问到私有属性或私有方法。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>实现代码的复用，相同的代码不需要重复的编写。</p><p>概念：子类拥有父类的所有方法和属性。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">(</span>父类名<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre><p><strong>子类/派生类，父类/基类，继承/派生</strong></p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>子类拥有父类以及父类的父类中封装的所有属性和方法</p><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>两种情况：</p><p>1）覆盖父类的方法：父类的方法实现和子类的方法实现完全不同</p><p>在子类中定义一个和父类同名的方法并且实现</p><p>2）对父类方法进行扩展：子类的方法实现包含父类的方法实现</p><ul><li>在子类重写父类的方法</li><li>在需要的位置使用super().父类方法来调用父类方法的执行</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>子类可以拥有多个父类，并且具有所有父类的属性和方法。</p><p>语法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 子类名<span class="token punctuation">(</span>父类名<span class="token number">1</span><span class="token punctuation">,</span> 父类名<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre><p><strong>注意不要有重名方法或属性</strong></p><h4 id="MRO–方法搜索顺序"><a href="#MRO–方法搜索顺序" class="headerlink" title="MRO–方法搜索顺序"></a>MRO–方法搜索顺序</h4><p>按照mro顺序，从左至右执行</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><p>可以增加代码的灵活度，以<strong>继承和重写父类方法</strong>为前提。</p><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>对象创建后，内存中就有了一个对象的实实在在的存在——实例</p><p>通常把：</p><ol><li>创建出来的对象叫做类的实例</li><li>创建对象的动作叫做实例化</li><li>对象的属性叫做实例属性</li><li>对象调用的方法叫做实例方法</li></ol><ul><li>每一个对象都有自己独立的内存空间，保存各自不同的属性</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部。</li></ul><p>类对象、实例对象</p><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><p>使用赋值语句，定义类属性。</p><p>通常使用类属性记录与这个类相关的特征。</p><p>不会用于记录具体对象的特征。</p><p>访问类属性：</p><ul><li>类名.属性</li><li>对象.类属性（不推荐）</li><li>使用 对象.类属性 = 值，会给对象创建一个属性</li></ul><h5 id="属性的获取机制"><a href="#属性的获取机制" class="headerlink" title="属性的获取机制"></a>属性的获取机制</h5><p>tool.count-&gt;首先在对象内部查找对象属性-&gt;没找到就向上寻找类属性</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>语法：</p><pre class=" language-python"><code class="language-python">@classmethod<span class="token keyword">def</span> 类方法名<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre><p>类方法需要使用修饰器来标识，告诉解释器这是一个类方法。</p><p>类方法的第一个参数是cls</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><h4 id="单例设计模式："><a href="#单例设计模式：" class="headerlink" title="单例设计模式："></a>单例设计模式：</h4><p>让类创建的对象，在系统中只有唯一的一个实例</p><p>每一次执行类名()返回的对象，内存地址是相同的</p><p>应用场景：音乐播放对象、回收站对象、打印机对象</p><h4 id="new方法"><a href="#new方法" class="headerlink" title="new方法"></a>new方法</h4><p>作用：</p><ul><li><p>在内存中为对象分配空间</p></li><li><p>返回对象的引用</p></li></ul><p>python解释器获得对象的引用后，将引用作为第一个参数，传递给init方法</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Music</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#创建对象时，new方法会被自动调用</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#为对象分配空间  使用super()访问父类方法</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#返回对象的引用</span>        <span class="token keyword">return</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span></code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序停止执行并且提示错误信息——抛出（raise）异常</p><p>接收到异常后做针对性的处理</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="简单的捕获异常语法"><a href="#简单的捕获异常语法" class="headerlink" title="简单的捕获异常语法"></a>简单的捕获异常语法</h4><p>try()捕获异常：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    尝试执行的代码<span class="token keyword">except</span><span class="token punctuation">:</span>    出现错误的处理</code></pre><h4 id="错误类型捕获"><a href="#错误类型捕获" class="headerlink" title="错误类型捕获"></a>错误类型捕获</h4><p>针对不同类型异常，做出不同的响应。</p><p>语法：</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211102134633688.png" alt="image-20211102134633688"></p><p>当Python解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型。</p><h5 id="未知错误"><a href="#未知错误" class="headerlink" title="未知错误"></a>未知错误</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"未知错误 %s"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span></code></pre><h4 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#尝试执行的代码</span>    <span class="token keyword">pass</span><span class="token keyword">except</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">except</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">except</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#没有异常才会执行的代码</span>    <span class="token keyword">pass</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"无论是否有异常，都会执行的代码"</span><span class="token punctuation">)</span></code></pre><h3 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h3><p>当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方。</p><p>如果传递到主程序，仍然没有异常处理，程序才会被终止。</p><h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3><ul><li>创建一个Exception对象</li><li>使用raise关键字抛出异常对象</li></ul><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>每一个以py结尾的Python源代码文件都是一个模块</p><h3 id="模块的导入方式"><a href="#模块的导入方式" class="headerlink" title="模块的导入方式"></a>模块的导入方式</h3><h4 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a>import导入</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> 模块名<span class="token number">1</span><span class="token keyword">import</span> 模块名<span class="token number">2</span></code></pre><p>通过<strong>模块名.</strong>使用模块提供的工具：全局变量、函数、类</p><p>使用as指定模块的别名：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> 模块名<span class="token number">1</span> <span class="token keyword">as</span> 别名</code></pre><p>模块别名应该符合<strong>大驼峰命名法</strong></p><h4 id="form…import导入"><a href="#form…import导入" class="headerlink" title="form…import导入"></a>form…import导入</h4><p>从某一个模块中，导入部分工具</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> 模块名 <span class="token keyword">import</span> 工具名</code></pre><p>导入之后：</p><ul><li>不需要通过模块名.</li><li>可以直接使用模块提供的工具</li></ul><p>注意：</p><p>如果两个模块存在同名的函数，那么后导入模块的函数，会覆盖先导入的函数。</p><p><strong>一旦发现冲突，可以使用as取别名</strong></p><h4 id="from…import-导入"><a href="#from…import-导入" class="headerlink" title="from…import*导入"></a>from…import*导入</h4><p>从模块导入所有工具</p><h3 id="模块的搜索顺序"><a href="#模块的搜索顺序" class="headerlink" title="模块的搜索顺序"></a>模块的搜索顺序</h3><ol><li>搜索当前目录指定模块名的文件，如果有就直接导入</li><li>如果没有，再搜索系统目录</li></ol><p><strong>文件起名不要和系统的模块文件重名！！！</strong></p><p>查看模块路径：<code>__file__</code></p><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a>__name__属性</h3><p>文件被导入时，直接执行的代码（没有任何缩进的代码）不需要被执行。</p><p>作用：测试模块的代码只在测试情况下被运行，而在被导入时不会被执行</p><p>原理：</p><p>__name__是Python的一个内置属性，记录着一个字符串：</p><ul><li>当执行当前程序时，__name__是为__main__</li><li>如果是被其他文件导入的，__name__是模块名</li></ul><p>使用方法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#测试代码</span>    <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>   m</code></pre><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一个包含多个模块的特殊目录</p><p>目录下有一个特殊的文件<strong>__init__.py</strong></p><p>作用：</p><p>使用import 包名可以一次性导入包中的所有模块</p><h4 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a>__init__.py</h4><p>外界使用包中的模块，需要在__init__.py中指定对外界提供的模块列表：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 从当前目录导入模块列表</span><span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> xxx</code></pre><h3 id="发布、安装、卸载模块"><a href="#发布、安装、卸载模块" class="headerlink" title="发布、安装、卸载模块"></a>发布、安装、卸载模块</h3><p>发布：</p><p>1)创建setup.py</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211106100948243.png" alt="image-20211106100948243"></p><p>2)构建模块</p><pre class=" language-yacas"><code class="language-yacas">python3 setup.py build </code></pre><p>3)生成发布压缩包</p><pre class=" language-yacas"><code class="language-yacas">python3 setup.py sdist</code></pre><p>安装：</p><pre class=" language-yacas"><code class="language-yacas">tar -zxvf xxx.tar.gzsudo python3 setup.py install</code></pre><p>卸载：</p><pre class=" language-yacas"><code class="language-yacas">sudo rm -r xxx</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>1个函数和3个方法</p><table><thead><tr><th>序号</th><th>函数/方法</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>open</td><td>打开文件，并且返回文件操作对象</td></tr><tr><td>02</td><td>read</td><td>将文件内容读取到内存</td></tr><tr><td>03</td><td>write</td><td>将指定内容写入文件</td></tr><tr><td>04</td><td>close</td><td>关闭文件</td></tr></tbody></table><h4 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h4><p>open函数的第一个参数是要打开的文件名：</p><ul><li>如果文件存在，返回文件操作对象</li><li>如果文件不存在，会抛出异常</li></ul><p>read方法可以一次性读入并返回文件的所有内容</p><pre class=" language-python"><code class="language-python">file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"README"</span><span class="token punctuation">)</span>text <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>文件指针：</strong></p><p>文件指针标记从哪个位置开始读取数据</p><p>第一次打开文件时，通常文件指针会指向<strong>文件的开始位置</strong></p><p>当执行了read方法后，文件指针会移动到<strong>读取内容的末尾</strong></p><p><strong>使用过一次read后，再次read将得不到内容</strong></p><h4 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h4><p>语法：</p><pre class=" language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"文件名"</span><span class="token punctuation">,</span> <span class="token string">"打开方式"</span><span class="token punctuation">)</span></code></pre><table><thead><tr><th>访问方式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常。</td></tr><tr><td>w</td><td>以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td>a</td><td>以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr><tr><td>r+</td><td>以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常。</td></tr><tr><td>w+</td><td>以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td>a+</td><td>以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr></tbody></table><p>以读写方式打开文件，会频繁的移动文件指针，<strong>影响文件的读写效率</strong>，开发中更多的时候会以<strong>只读、只写</strong>的方式来操作文件。</p><h4 id="按行读取文件内容"><a href="#按行读取文件内容" class="headerlink" title="按行读取文件内容"></a>按行读取文件内容</h4><p>read方法默认会把文件的所有内容一次性读取到内存，<strong>如果文件太大，会对内存的占用非常严重。</strong></p><p><strong>readline方法：</strong></p><ul><li>一次读取一行内容</li><li>方法执行后，会将文件指针移动到下一行，准备再次读取</li></ul><pre class=" language-python"><code class="language-python">file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"README.txt"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#读取一行内容</span>    text <span class="token operator">=</span> file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#判断是否读到内容</span>    <span class="token keyword">if</span> <span class="token operator">not</span> text<span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token comment" spellcheck="true">#每读一行的末尾已经有了一个'\n'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="文件读写案例——复制文件"><a href="#文件读写案例——复制文件" class="headerlink" title="文件读写案例——复制文件"></a>文件读写案例——复制文件</h4><pre class=" language-python"><code class="language-python">file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"README.txt"</span><span class="token punctuation">)</span>file_w <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#读取一行内容</span>    text <span class="token operator">=</span> file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#判断是否读到内容</span>    <span class="token keyword">if</span> <span class="token operator">not</span> text<span class="token punctuation">:</span>        <span class="token keyword">break</span>    file_w<span class="token punctuation">.</span>write<span class="token punctuation">(</span>text<span class="token punctuation">)</span>file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>file_w<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="文件-目录的常用管理操作"><a href="#文件-目录的常用管理操作" class="headerlink" title="文件/目录的常用管理操作"></a>文件/目录的常用管理操作</h4><p>在Python中，如果希望通过程序实现创建、重命名、删除、改变路径等功能，需要导入<strong>os模块</strong>。</p><p>文件操作：</p><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>01</td><td>rename</td><td>重命名文件</td><td>os.rename(源文件名, 目标文件名)</td></tr><tr><td>02</td><td>remove</td><td>删除文件</td><td>os.remove(文件名)</td></tr></tbody></table><p>目录操作：</p><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>01</td><td>listdir</td><td>目录列表</td><td>os.listdir(目录名)</td></tr><tr><td>02</td><td>mkdir</td><td>创建目录</td><td>os.mkdir(目录名)</td></tr><tr><td>03</td><td>rmdir</td><td>删除目录</td><td>os.rmdir(目录名)</td></tr><tr><td>04</td><td>getcwd</td><td>获取当前目录</td><td>os.getcwd()</td></tr><tr><td>05</td><td>chdir</td><td>修改工作目录</td><td>os.chdir(目标目录)</td></tr><tr><td>06</td><td>path.isdir</td><td>判断是否是文件</td><td>os.path.isdir(文件路径)</td></tr></tbody></table><h2 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h2><p><strong>Python 2.x默认使用ASCII编码</strong></p><p><strong>Python 3.x默认使用UTF-8编码</strong></p><p>UTF-8编码中，大多数<strong>汉字使用3个字节</strong>来表示</p><h3 id="Python-2-x中使用中文"><a href="#Python-2-x中使用中文" class="headerlink" title="Python 2.x中使用中文"></a>Python 2.x中使用中文</h3><p>在Python 2.x文件的第一行增加以下代码，解释器会以utf-8来处理：</p><pre class=" language-yacas"><code class="language-yacas"># *-* coding:utf8 *-*或者# coding=utf8</code></pre><p>Python 2.x中在<strong>字符串引号前加u</strong>，告诉解释器这是一个unicode字符串</p><pre class=" language-python"><code class="language-python">strr <span class="token operator">=</span> u<span class="token string">"xxx"</span></code></pre><h2 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h2><p>eval()函数将<strong>字符串</strong>当成<strong>有效的表达式</strong>来求值并<strong>返回计算结果</strong>。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> eval<span class="token punctuation">(</span><span class="token string">"1 + 1"</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token comment" spellcheck="true">#将字符串转为列表</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>eval<span class="token punctuation">(</span><span class="token string">"[1,2,3,4,5]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span></code></pre><p>案例——计算器</p><pre class=" language-python"><code class="language-python">input_str <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入算术题："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>eval<span class="token punctuation">(</span>input_str<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>在开发时不要使用eval直接转换input的结果</strong></p><p><code>__import__(&#39;os&#39;).system(&#39;touch aaa&#39;)</code></p><p>利用eval直接操作文件</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1）<strong>python中幂运算是<em>**</em></strong> **，不是^</p><p>2）产生随机数：random()：生成1-10随机数：random.randint(1,10)</p><p>3）-3**2=-9，幂的优先级比左侧高比右侧低</p><p>4）列表转字符串可以使用.join()方法：</p><pre class=" language-yacas"><code class="language-yacas">str.join(sequence)</code></pre><p>表示用str连接sequence里的字符</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'hellopython'</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> list<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'hellopython'</span></code></pre><p>5）split()方法</p><p>split() 通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。</p><p>语法：</p><pre class=" language-python"><code class="language-python">str<span class="token punctuation">.</span>split<span class="token punctuation">(</span>str<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> num<span class="token operator">=</span>string<span class="token punctuation">.</span>count<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Python爬虫时需要保存图片、图片名称的获取，可以采用以下方法：</p><pre class=" language-python"><code class="language-python">url <span class="token operator">=</span> <span class="token string">"http://www.baidu.com/python/image/123456.jpg"</span>path <span class="token operator">=</span>url<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#输出结果为 '1'</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TPshop商城功能测试</title>
      <link href="/Zzhanp.github.io/2021/11/04/tpshop-shang-cheng-gong-neng-ce-shi/"/>
      <url>/Zzhanp.github.io/2021/11/04/tpshop-shang-cheng-gong-neng-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="TPshop商城项目"><a href="#TPshop商城项目" class="headerlink" title="TPshop商城项目"></a>TPshop商城项目</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="软件组成"><a href="#软件组成" class="headerlink" title="软件组成"></a>软件组成</h3><p>前台、前端、后台、后端</p><p>应用服务器：前台的请求进行存储转发处理的应用服务</p><p>常见Web服务器：</p><p>Apache：稳定性较好，对于PHP项目的支持非常好</p><p>Nginx：并发性比较好，常和其他Web服务器一起使用</p><p>数据库：MySQL、Oracle</p><p>硬件服务器：物理机、云服务器、虚拟机</p><h3 id="搭建环境遇到的坑"><a href="#搭建环境遇到的坑" class="headerlink" title="搭建环境遇到的坑"></a>搭建环境遇到的坑</h3><h4 id="一、phpstudy的mysql无法启动"><a href="#一、phpstudy的mysql无法启动" class="headerlink" title="一、phpstudy的mysql无法启动"></a>一、phpstudy的mysql无法启动</h4><p>场景：点击启动mysql后，很快mysql就会停止。</p><p>原因：phpstudy的mysql和电脑本身的mysql服务冲突</p><p>解决方案：到服务中将电脑本身的mysql服务停止即可</p><h4 id="二、配置网站时提示添加sql-mode"><a href="#二、配置网站时提示添加sql-mode" class="headerlink" title="二、配置网站时提示添加sql-mode"></a>二、配置网站时提示添加sql-mode</h4><p>解决方案：在phpstudy的mysql文件夹中，打开mysql.ini，在[mysqlld]中添加sql-mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</p><h4 id="三、配置完加载页面是php报错"><a href="#三、配置完加载页面是php报错" class="headerlink" title="三、配置完加载页面是php报错"></a>三、配置完加载页面是php报错</h4><p>具体报错：Use of undefined constant level - assumed ‘level’ (this will throw an Error in a future version of PHP</p><p>原因：大概是高级版本的PHP不太兼容</p><p>解决方案：在phpstudy中选择php版本为5.4</p><h2 id="熟悉项目"><a href="#熟悉项目" class="headerlink" title="熟悉项目"></a>熟悉项目</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>知道干什么以及怎么干</p><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><ul><li>熟悉项目的核心模块：登录、注册、加购物车、购买等等。</li><li>熟悉项目的核心业务流程</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>熟悉项目的用户和角色：项目是给谁用的？</li><li>熟悉项目的组织架构：包含的功能模块有哪些？</li><li>熟悉项目的核心业务流程：项目是做什么的？</li><li>熟悉项目的核心功能模块：项目中最重要的功能模块有哪些？</li></ul><h3 id="信息来源"><a href="#信息来源" class="headerlink" title="信息来源"></a>信息来源</h3><p>已存在的文档：需求说明书、设计文档、测试用例、用户使用手册等</p><p>项目中环境：开发环境、测试环境、生产环境</p><p>询问项目组相关成员</p><h2 id="TPshop"><a href="#TPshop" class="headerlink" title="TPshop"></a>TPshop</h2><h3 id="熟悉项目-1"><a href="#熟悉项目-1" class="headerlink" title="熟悉项目"></a>熟悉项目</h3><h4 id="给谁用："><a href="#给谁用：" class="headerlink" title="给谁用："></a>给谁用：</h4><p>前台：游客、注册会员</p><p>后台：客服、仓库管理员、超级管理员</p><h4 id="组织架构："><a href="#组织架构：" class="headerlink" title="组织架构："></a>组织架构：</h4><p>拆分：</p><ul><li><p>后台：</p></li><li><p>前台：从上到下、从左到右</p></li></ul><h4 id="核心业务流程："><a href="#核心业务流程：" class="headerlink" title="核心业务流程："></a>核心业务流程：</h4><p>商品购买流程</p><p>商品发货流程</p><p>商品退换货流程</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>会员、商品、订单等（在业务流程中找）</p><p>根据业务流程及组织架构，标出最重要的模块</p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>Web服务器：Apache</p><p>数据库：MySQL</p><p>PHP网站框架</p><h2 id="测试流程（重点）"><a href="#测试流程（重点）" class="headerlink" title="测试流程（重点）"></a>测试流程（重点）</h2><p>作用：有序有效开展测试工作的基本步骤</p><ol><li><strong>需求评审</strong>：对于产品编写需求文档进行评审和评估的过程</li><li><strong>编写测试计划和测试方案</strong>：实施测试过程中需要的设备、资源、时间等信息</li><li><strong>测试用例设计和评审</strong></li><li><strong>测试执行并提交缺陷</strong></li><li><strong>编写测试报告</strong>：对于整体测试过程的总结和质量的说明</li></ol><h4 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h4><p>项目相关人员就软件需求进行确认和评估的相关活动。</p><p>作用：保证需求说明书的完整、准确，保证项目团队对需求的理解达成一致。</p><p>人员：产品、开发、测试</p><p>测试职责：</p><ul><li>读懂需求：确认自己对需求有清晰的理解，没有疑惑</li><li>找出错误：确认需求文档完整、准确，能够指导后期工作</li><li>给出建议：对需求中不合适的地方提出自己的修改建议</li></ul><h4 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h4><p>定义：测试计划是一个测试过程中的文档，描述了要进行的测试活动的范围、方法、资源和进度。</p><p>核心内容：</p><ul><li>明确的测试目标与测试范围：最终要达成的要求、测试多少</li><li>执行计划的角色与职责：什么人干什么事</li><li>任务的进度安排与资源分配：花费多长时间，需要哪些资源</li><li>风险估计和应急计划：可能遇到的风险，以及如何应对</li><li>测试的准入/准出标准：什么时候开始，什么时候结束</li></ul><h4 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h4><p>测试过程中的文档，从测试的技术角度去分析需求，在方向上明确要怎么测，分析结果重点在于测试策略与技术实现。</p><p>核心内容：</p><ul><li>测试策略：具体使用的方式方法，如何完成测试工作</li><li>测试环境的规划：具体实施需要的测试环境</li><li>测试工具的设计和选择：具体实施测试工作可能需要的一些工具</li></ul><h5 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h5><ul><li><strong>界面（UI）测试</strong></li><li><strong>功能测试</strong></li><li><strong>易用性测试</strong></li><li><strong>性能测试</strong></li><li><strong>安全性测试</strong></li><li><strong>兼容性测试</strong></li><li>回归测试</li></ul><h4 id="测试计划与方案的对比"><a href="#测试计划与方案的对比" class="headerlink" title="测试计划与方案的对比"></a>测试计划与方案的对比</h4><p>区别：</p><ul><li>测试计划是管理型文档，描述“测试什么，谁来测试”</li><li>测试方案是技术型文档，描述“怎么测”</li></ul><p>联系：</p><ul><li>实际项目中测试计划与方案可以合并为一个文档</li><li>一般有测试组长编写指制定</li></ul><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><p>tp_users</p><p>tp_goods</p><p>tp_order</p><p>tp_cart</p><h2 id="恢复tpshop数据"><a href="#恢复tpshop数据" class="headerlink" title="恢复tpshop数据"></a>恢复tpshop数据</h2><ul><li>把tpshop相关的数据库全部删除</li><li>到tpshop的安装目录</li><li>删除install.lock</li><li>打开127.0.0.1/install重新安装</li></ul><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>测试步骤：</p><p>需求分析 ：<strong>需求文档、产品原型图、UI设计图</strong></p><p>测试点整理：能够直接编写测试用例的程度</p><ul><li>根据需求拆分不同的功能点：不同意思拆分出即可，观察法、用例设计方法</li><li>可以按照原型图拆分：所见及所测，与被测对象紧密相关的功能</li></ul><p>编写测试用例：按照用例模板编写</p><ul><li>能看懂：确保每个用例通俗易懂</li><li>能执行：测试用例清晰准确，用例中每个步骤都是可执行的</li></ul><p>评审测试用例：查漏补缺、理解一致、指导执行</p><p>执行测试用例：</p><ul><li>严格按照测试用例书写的步骤执行</li><li>失败的用例，及时提交缺陷报告</li></ul><p>缺陷跟踪：提bug：可复现、唯一性、规范性</p><h3 id="轮播图功能测试"><a href="#轮播图功能测试" class="headerlink" title="轮播图功能测试"></a>轮播图功能测试</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026134951016.png" alt="image-20211026134951016"></p><h4 id="整理测试点"><a href="#整理测试点" class="headerlink" title="整理测试点"></a>整理测试点</h4><ul><li>显示1-5张banner图片：边界值：1、5、3、0、6</li><li>自动轮播，3秒切换一张：观察法</li><li>一张不轮播</li><li>鼠标悬停不轮播</li><li>实心为当前图</li><li>点击图片可以跳转</li><li>点击左切换一张图片</li><li>点击右切换一张图片</li></ul><p>动作+结果</p><p>测试结果：</p><p>pass、failed、block、N/A</p><h4 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h4><table><thead><tr><th>ID</th><th>模块</th><th>优先级</th><th>用例标题</th><th>预置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>Tpshop-banner-001</td><td>轮播图</td><td>P2</td><td>验证一张轮播图显示</td><td>1.网络正常     2.管理员在后台设置显示1张轮播图</td><td>1.打开浏览器，访问商城地址     2.观察banner图片显示数量</td><td>1</td><td>显示1张图片且显示正确</td></tr><tr><td>Tpshop-banner-002</td><td>轮播图</td><td>P2</td><td>验证没有轮播图时是否显示图片</td><td>1.网络正常     2.管理员在后台设置显示0张轮播图</td><td>1.打开浏览器，访问商城地址     2.观察banner图片显示数量</td><td>0</td><td>不显示图片</td></tr><tr><td>Tpshop-banner-003</td><td>轮播图</td><td>P2</td><td>验证轮播图切换时间是否正确</td><td>1.网络正常     2.管理员在后台设置显示5张轮播图</td><td>1.打开浏览器，访问商城地址     2.观察banner切换时间</td><td>0</td><td>3秒钟切换一张</td></tr><tr><td>Tpshop-banner-004</td><td>轮播图</td><td>P2</td><td>验证单张图片是否轮播</td><td>1.网络正常     2.管理员在后台设置显示1张轮播图</td><td>1.打开浏览器，访问商城地址     2.观察轮播图是否轮播</td><td>1</td><td>轮播图不轮播</td></tr></tbody></table><h4 id="评审测试用例"><a href="#评审测试用例" class="headerlink" title="评审测试用例"></a>评审测试用例</h4><p>查漏补缺、理解一致、指导执行</p><h4 id="执行测试用例"><a href="#执行测试用例" class="headerlink" title="执行测试用例"></a>执行测试用例</h4><h3 id="购物车功能测试"><a href="#购物车功能测试" class="headerlink" title="购物车功能测试"></a>购物车功能测试</h3><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026190518711.png" alt="image-20211026190518711" style="zoom: 80%;"></p><h3 id="会员列表（列表类）"><a href="#会员列表（列表类）" class="headerlink" title="会员列表（列表类）"></a>会员列表（列表类）</h3><p>判定表法、等价类边界值法</p><ul><li>功能</li><li>UI效果（是否可拖拽）</li><li>按钮：快速点击，是否重复发送</li><li>后台、前台</li></ul><h3 id="抢购"><a href="#抢购" class="headerlink" title="抢购"></a>抢购</h3><ul><li>基本功能</li><li>列表</li></ul><h2 id="非功能"><a href="#非功能" class="headerlink" title="非功能"></a>非功能</h2><p>基本测试策略：</p><ul><li>冒烟测试：基本功能检查、核心业务流程测试</li><li>单功能测试</li><li>集成测试与回归</li><li>系统测试与回归</li><li>验收测试与回归</li></ul><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><p>概念：不同平台、系统都能正常工作</p><p>测试关注点（Web）：</p><ul><li>浏览器：IE、Chrome、FireFox</li><li>操作系统：Windows、Linux、mac等</li><li>网络</li><li>分辨率</li></ul><h3 id="界面测试"><a href="#界面测试" class="headerlink" title="界面测试"></a>界面测试</h3><p>测试用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件是否符合客户使用习惯</p><ul><li>布局</li><li>风格</li><li>按钮</li><li>测试基本原则：参照UI设计图</li><li>若无原型图：<ul><li>导航测试</li><li>图形测试</li><li>内容测试（有无错别字）</li><li>整体界面风格测试</li></ul></li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>易懂、易学</p><p>关注点：</p><ul><li>用户群体</li><li>计算机水平</li><li>项目复杂性</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>什么时候考虑：</p><ul><li>对性能有要求</li><li>用户量大</li><li>并发测试、压力测试、负载测试</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>关注点：</p><p>输入数据：登录时密码是否进行加密以及密码是否容易破解，敏感信息遮挡处理，不能复制</p><p>传输数据：加密要有复杂度</p><p>输出数据：数据库中敏感信息要加密</p><h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><ul><li>测试工作的经过与结果</li><li>风险评估</li><li>缺陷汇总与分析</li><li>测试工作总结与改进</li></ul><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>协议://ip或域名:端口号/资源路径</p><p>端口号：</p><ul><li>http：默认端口80</li><li>https：默认端口443</li><li>ssh：默认端口22</li></ul><p>参数：用?与URL的主体部分分开</p><p>格式：参数名=参数值，有多个参数值用&amp;拼接</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><pre class=" language-yacas"><code class="language-yacas">POST http://localhost/index.php?m=Home&c=User&a=do_login&t=0.04464880318635145 HTTP/1.1Host: localhostConnection: keep-aliveContent-Length: 53sec-ch-ua: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"Accept: application/json, text/javascript, */*; q=0.01Content-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestusername=18500860000&password=123456&verify_code=8888</code></pre><ul><li><p>请求内容</p><ul><li>请求行：第一行<ul><li>请求方式：POST</li><li>请求地址</li><li>协议及版本</li></ul></li><li>请求头：第一行之后，空行之前：描述客户端相关信息</li><li>请求体：</li></ul></li><li><p>请求方式：POST和GET</p><ul><li>GET：用于查询，如搜索商品，参数在URL中，不是很安全</li><li>POST：用于提交数据，相对比较安全，如登录、注册等。</li></ul></li></ul><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>响应内容：</p><ul><li>响应头</li><li>响应行</li><li>响应体</li></ul><p>响应状态码：</p><ul><li>2xx：成功，如200</li><li>3xx：重定向，如301</li><li>4xx：客户端存在问题，如404</li><li>5xx：服务器端存在问题，如501</li></ul><h4 id="面试题：GET和POST的区别"><a href="#面试题：GET和POST的区别" class="headerlink" title="面试题：GET和POST的区别"></a>面试题：GET和POST的区别</h4><ul><li><strong>最直观的区别就是GET把参数包含在URL中，POST通过request body（请求体）传递参数。</strong></li><li><strong>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</strong></li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li><strong>GET请求在URL中传送的参数是有长度限制的，而POST没有（注意：这个限制是由浏览器导致）。</strong></li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h3 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h3><h4 id="删除请求"><a href="#删除请求" class="headerlink" title="删除请求"></a>删除请求</h4><ul><li>菜单删除</li><li>命令行删除：cls、clear</li><li>键盘delete</li><li>快捷键CTRL+x</li></ul><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><ol><li><p>点击Filters页签，勾选“Use Filters”</p></li><li><p>Hosts下方的第二个下拉框，选择“Show Only the following Hosts”</p></li><li><p>在下方输入框中输入要抓包的主机地址（多个地址用英文分号隔开，如：localhost;127.0.0.1）</p></li><li><p>点击右上角的“Actions”,选择“Run  Filterset  Now”</p></li><li><p>如果取消过滤，去掉“Use Filters”的勾选</p></li></ol><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ul><li><p>修改请求</p><ol><li><p>进入添加会员的页面，填写正确的手机号码和其他信息</p></li><li><p>打开fiddler拦截开关：Rules ==》 Automatic Breakpoints ==》 Before Requests</p></li><li><p>回到添加会员界面，点击提交按钮</p></li></ol></li></ul><ol start="4"><li>回到Fiddler，修改【请求体】，如修改手机号码内容<ol start="5"><li>点击Fiddler中请求下方的绿色按钮“Run to Completion”</li><li>关闭Fiddler拦截开关：Rules ==》 Automatic Breakpoints ==》 Disabled</li></ol></li></ol><ul><li>修改响应（扩展）</li></ul><ul><li><ol><li>进入添加会员的页面，填写正确的手机号码和其他信息</li><li>打开fiddler拦截开关：Rules ==》 Automatic Breakpoints ==》 After Responses</li><li>回到添加会员界面，点击提交按钮</li><li>回到Fiddler，修改【响应体】，如修改【操作提示】的内容</li><li>点击Fiddler中请求下方的绿色按钮“Run to Completion”</li><li>关闭Fiddler拦截开关：Rules ==》 Automatic Breakpoints ==》 Disabled</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web测试 </tag>
            
            <tag> 功能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>功能测试</title>
      <link href="/Zzhanp.github.io/2021/11/04/gong-neng-ce-shi/"/>
      <url>/Zzhanp.github.io/2021/11/04/gong-neng-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按是否覆盖源代码"><a href="#按是否覆盖源代码" class="headerlink" title="按是否覆盖源代码"></a>按是否覆盖源代码</h3><p>黑盒：不关注代码逻辑，只关注输入输出。</p><p>白盒：关注代码逻辑。</p><p>灰盒测试：多用于集成测试阶段。</p><h3 id="按测试阶段"><a href="#按测试阶段" class="headerlink" title="按测试阶段"></a>按测试阶段</h3><p>单元测试：单个功能模块，对软件中最小可测单元进行检查和验证</p><p>集成测试：组装测试，组装成完整功能，将所有程序模块进行有序的、递增的测试，重点测试不同模块的接口部分。</p><p>系统测试：将整个软件系统看成一个整体进行测试，依据是软件需求说明书，软硬件</p><p>验收测试：检验软件是否符合用户需求的测试：α：内测 β：公测 γ：候选发布版本</p><h3 id="按是否运行"><a href="#按是否运行" class="headerlink" title="按是否运行"></a>按是否运行</h3><p>静态：不运行，界面或文档可能存在</p><p>动态：实际运行被测程序</p><h3 id="按是否自动化"><a href="#按是否自动化" class="headerlink" title="按是否自动化"></a>按是否自动化</h3><p>手工测试</p><p>自动化测试</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>冒烟测试：针对最基本功能，保证基本的功能和流程能走通。</p><p>回归测试：修复一个bug后，把之前的测试用例在新的代码下再次测试。</p><p>随机测试：每个人不同的经验、角度。</p><p>探索测试：</p><h2 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>职责明确，不响应需求的变化。应用于大型项目。</p><p>可研与计划－需求分析－概要设计－详细设计－编码－软件测试－运行维护</p><p>可研与计划：可行性研究报告</p><p>需求分析：需求规格说明书</p><p>概要设计：概要设计文档（架构师）</p><p>详细设计：详细设计文档（开发）</p><p>编码：敲代码</p><p>软件测试：测试报告</p><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>需求分析-概要设计-详细设计-编码-单元测试-集成测试-系统测试-验收测试</p><p>测试的活动更多，并没有解决瀑布模型不响应需求变化的缺点。</p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><ul><li>开发V：需求分析-概要设计-详细设计-编码-<strong>集成-实施-交付</strong></li><li>缺点：技术和管理要求比较高</li><li>测试V：验收系统测试设计-集成测试设计-单元测试设计-单元测试-集成测试-系统测试-验收测试</li><li>测试参与了软件开发全生命周期</li></ul><h2 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h2><p>功能性：检察业务功能是否满足需求</p><p>可靠性：容错性能、纠错能力</p><p>易用性：易读易懂</p><p>效率：性能（响应时间、消耗的资源）</p><p>可维护性：为后续功能的开发与维护提供便利</p><p>可移植性：不同的软件环境和硬件环境</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个为了特定目的（验证产品的功能实现是否满足用户需求）而设计的的包含（测试输入、执行条件、预期结果）的文档。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>便于理清测试思路，确保需覆盖测试的功能点无遗漏。</li><li>便于测试工作量的评估</li><li>便于提前准备测试数据</li><li>便于把控测试工作进度</li><li>便于回归测试</li><li>便于测试工作的组织，提高测试效率，降低测试交接成本</li></ul><h3 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h3><ul><li>用例编号</li><li>用例标题</li><li>测试项目</li><li>用例级别</li><li>预置条件</li><li>测试输入</li><li>执行步骤</li><li>预期结果</li></ul><h2 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在所有测试数据中，具有某种共同特征的数据子集。</p><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>满足要求：有效等价类</p><p>不满足要求：无效等价类</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>有大量数据测试输入，但是没法穷举测试。</strong>如输入框、下拉列表、单选复选框，需要同时提交，对于每种输入都需要大量测试输入验证</p><p>典型代表：<strong>页面级的输入框类测试</strong></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p><strong>需求分析</strong></p></li><li><p><strong>划分等价类：</strong></p><ul><li><p>有效：满足所有需求</p></li><li><p>无效：<strong>规则（需求）、长度、类型、是否为空（必填项）、是否重复</strong>。只要一项不满足即可。</p></li></ul></li><li><p><strong>设计测试用例</strong></p></li></ol><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>一、QQ账号：</p><p>需求分析：6-10位自然数</p><p>长度：6-10位</p><p>类型：自然数</p><p><strong>划分等价类：</strong></p><p>有效等价类：6-10位自然数，有效数据：123456</p><p>无效等价类：</p><p>长度：小于5位、大于10位</p><p>类型：非自然数，包含字母、符号、中文、空格，空</p><p>二、电话号码：</p><p><strong>需求分析：</strong>验证某城市电话号码正确性</p><p>区号：空或三位数字</p><p>前缀码：非0且非1开头的三位数字</p><p>后缀码：四位数字</p><p><strong>有效等价类：</strong></p><p><strong>无效等价类：</strong></p><p>三、新浪邮箱登录</p><p><strong>需求分析：</strong></p><p>测试目的：邮箱能否登录</p><p>测试条件：</p><p>邮箱名：4-16位字符，支持英文、数字、下划线（不能全是数字或者下划线）</p><p>密码：6-18位字符</p><p><strong>有效等价类：</strong></p><p><strong>无效等价类：</strong></p><p>挑一个最小的一个最大的</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>单模块测试中，用例标题具有唯一性。</p><p>必要步骤尽可能清楚。</p><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>开发人员常常在边界的位置容易出现问题，因此需要针对边界位置再测试。</p><p>对于等价类划分法的完善和补充。</p><p><strong>针对有边界范围的批量数据的输入类测试（重点关注边界）</strong></p><p><strong>典型代表：输入框（有边界范围区间）</strong></p><h3 id="边界范围确定"><a href="#边界范围确定" class="headerlink" title="边界范围确定"></a>边界范围确定</h3><p>选取正好等于、刚好大于、刚好小于边界的值作为测试数据。</p><ul><li>上点：边界上的点（正好等于）</li><li>离点：距离上点最近的点（刚好大于、刚好小于）</li><li>内点：范围内的点（区间范围内的点）</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>明确需求：测试目的、测试条件</p><p>划分等价类：有效等价类、无效等价类</p><p>确认边界范围值：上点、离点（可以优化）、内点（可以和有效等价类的取值合并）</p><p>提取数据编写用例：</p><p><strong>上点需要单独列出。</strong></p><h3 id="边界取值优化"><a href="#边界取值优化" class="headerlink" title="边界取值优化"></a>边界取值优化</h3><p>内点：必选（建议选择中间范围）</p><p>上点：必须选</p><p>离点：可以优化，取和上点取值相反的取值点即可（上点有效，离点选无效 ）</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一、QQ</p><p>上点：6 位、10位</p><p>离点：5位、11位</p><p>内点：8位</p><p>二、标题长度</p><p>标题长度大于0，小于等于30个字符。</p><p>边界值：</p><p>上点：0个、30个</p><p>离点：1个，31个</p><p>内点：15个</p><p>三、邮箱登录</p><p>邮箱名边界值：</p><p>上点：4，16</p><p>离点：3，17</p><p>内点：10</p><p>密码边界值：</p><p>上点：6，18</p><p>离点：5，19</p><p>内点：12</p><h2 id="判定表法"><a href="#判定表法" class="headerlink" title="判定表法"></a>判定表法</h2><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>若用户欠费或者关机，则不允许主被叫</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖（制约）关系。</p><p><strong>常见词汇：如果…那么…</strong></p><p>局限性：判定表一般适用于条件组合数量较少的情况。</p><h3 id="判定表构成"><a href="#判定表构成" class="headerlink" title="判定表构成"></a>判定表构成</h3><p>条件桩：列出问题中所有条件。</p><p>动作桩：列出问题中可能采取的操作。</p><p>条件项：列出条件的对应取值。</p><p>动作项：列出条件项的各种取值情况下应该采取的动作结果。</p><p><strong>规则：判定表中贯穿条件项和动作项的一列就是一条规则。</strong></p><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>明确需求</p><p>画出判定表：</p><ul><li>列出条件桩和动作桩</li><li>填写条件项，对条件进行全组合</li><li>根据条件项的组合确定动作项</li><li>简化、合并相似规则（有相同的动作）</li></ul><p>根据规则编写测试用例</p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>一、订购单检查</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211024000021774.png" alt="image-20211024000021774"></p><p>二、文件修改</p><p>如想对文件进行修改，需要遵守以下规则： 输入的第一列字符必须是A或B，第二列字符必须是一个数字， 如果第一列字符不正确，则给出信息L； 如果第二列字符不正确，则给出信息M。 如果两列字符输入正确，则修改文件成功， 如果两列字符都输入错误，则给出信息L、M。</p><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><h2 id="正交法"><a href="#正交法" class="headerlink" title="正交法"></a>正交法</h2><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>也叫流程图法，是用流程图描述用户的使用场景，然后通过覆盖路程路径来设计测试用例。</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>用户使用角度：用户平时使用的不是单个功能，而是多个功能组合起来进行使用。</p><p>测试人员角度：平时测试的都是单个功能点，容易忽略多个功能的组合测试。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>根据实际的应用场景，对于多个功能之间的组合测试，可以使用场景法。</p><p>一般在测试的后期，对整个系统的模块功能进行全部的<strong>组合测试</strong>。</p><p>步骤：</p><ul><li>需求分析</li><li>绘制流程图</li><li>设计测试用例</li></ul><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>要求：有<strong>实际项目测试经验</strong>的人使用。</p><p>定义：通过<strong>直觉（经验）</strong>或者智慧推测系统可能出现问题的地方进行再次测试。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>1.时间紧迫：通过以往类似项目的经验，提取当前项目中核心模块（出现问题较多）进行再次测试。</p><p>2.时间宽裕：在基础测试的基础上，将原有模块（存在问题较多）进行再次细化测试。</p><h2 id="状态迁移法"><a href="#状态迁移法" class="headerlink" title="状态迁移法"></a>状态迁移法</h2><p>是一种基于产品规格分析，对系统的每个状态及与状态相关的功能进行测试，通过不同的状态验证程序的逻辑流程。</p><p>适用场景：</p><ul><li>在业务流程中涉及到了复杂的业务场景（即业务状态的迁移）。</li><li>这些业务场景在需求规格说明书中往往不能够完全阐述清楚，容易出现遗漏。</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>明确状态节点：分析被测试对象的需求规格说明，明确被测对象的状态节点数量。</li><li>绘制状态迁移图：利用圆圈表示状态节点，有向箭头表示状态间的迁移关系。</li><li>绘制状态迁移树：根据状态迁移图的节点和箭头绘制状态迁移树</li><li>抽取测试路径设计用例：根据迁移树抽取测试路径，从左至右，横向抽取，每条路径构成一条测试规则。</li></ol><h3 id="案例分析1–飞机售票系统"><a href="#案例分析1–飞机售票系统" class="headerlink" title="案例分析1–飞机售票系统"></a>案例分析1–飞机售票系统</h3><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211030161120223.png" alt="image-20211030161120223"></p><ol><li>明确状态节点：预定、已支付、已出票、已使用、已取消</li><li>绘制状态迁移图</li><li>绘制状态迁移树</li><li>设计用例</li></ol><h3 id="案例分析2–下单流程"><a href="#案例分析2–下单流程" class="headerlink" title="案例分析2–下单流程"></a>案例分析2–下单流程</h3><p><img src="/Zzhanp.github.io//zhangzhanpeng.top/2021/11/04/gong-neng-ce-shi/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20211030210601131.png" alt="image-20211030210601131"></p><p>状态节点：</p><p>等待付款、待发货、待收货、待评价、已完成、已取消、已作废</p><p>路径：</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211030211710878.png" alt="image-20211030211710878"></p><h2 id="业务流程测试"><a href="#业务流程测试" class="headerlink" title="业务流程测试"></a>业务流程测试</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ul><li>椭圆：开始/结束</li><li>箭头：路径、流程的走向</li><li>平行四边形：数据的输入/输出</li><li>矩形：处理/步骤/过程</li><li>菱形：判断</li></ul><p>绘制原则：</p><ul><li>流程正确，不能遗漏路径</li><li>先判定，再有判断结果</li><li>主流程保持在流程图的中间位置，方便阅读</li></ul><h3 id="业务流程测试-1"><a href="#业务流程测试-1" class="headerlink" title="业务流程测试"></a>业务流程测试</h3><ul><li>关注点在核心业务是否能够跑通</li><li>重点不是关注单个功能模块的细节点</li></ul><p>测试时机：</p><ul><li>上线前进行业务流程测试的确认</li><li>单功能模块基本可用的情况下，尽早进行（冒烟测试）</li></ul><h3 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h3><ul><li>需求分析，明确流程</li><li>画出流程图</li><li>编写测试用例</li></ul><h3 id="案例1–TPshop业务流程"><a href="#案例1–TPshop业务流程" class="headerlink" title="案例1–TPshop业务流程"></a>案例1–TPshop业务流程</h3><h2 id="测试用例设计总结"><a href="#测试用例设计总结" class="headerlink" title="测试用例设计总结"></a>测试用例设计总结</h2><p>等价类：具有输入功能，但输入之间没有组合关系</p><p>边界值：输入有边界，如长度、类型</p><p>判定表、因果图：多输入、多输出、输入与输入之间存在组合关系、输入与输出之间存在依赖或制约关系</p><p>正交法：用最少的测试用例获得最大测试覆盖率</p><p>场景法、流程图：多个功能的组合测试</p><p>错误推测法：最后使用来进一步补充测试用例</p><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><p>定义：软件在使用过程中存在的任何问题，都叫软件的缺陷，简称bug。（依据：需求说明书）</p><h3 id="判定标准"><a href="#判定标准" class="headerlink" title="判定标准"></a>判定标准</h3><ul><li><p>软件未实现需求说明书中明确要求的功能–中高级（没有做）</p></li><li><p>软件出现了需求说明书中指明不应该出现的错误–中高级（做错了）</p></li><li><p>软件实现的功能超出需求说明书指明的范围（做多了）</p></li><li><p>软件未实现需求说明书中虽未明确指明但应该实现的要求（没做好）</p><!--一般指国际/国家/行业/企业标准规范或者法规的要求--></li><li><p>软件难以理解，不易使用，运行缓慢，用户体验不好。（不完美）（优先级较低）</p></li></ul><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>需求阶段：需求描述不易理解，有歧义、错误等。</li><li>设计阶段：设计文档存在错误或者缺陷。</li><li>编码阶段：代码出现错误。</li><li>运行系统：软硬件系统本身故障导致软件缺陷。</li></ul><h3 id="软件缺陷核心内容"><a href="#软件缺陷核心内容" class="headerlink" title="软件缺陷核心内容"></a>软件缺陷核心内容</h3><ul><li>缺陷的标题——描述缺陷的核心问题</li><li>缺陷的预置条件——缺陷产生的前体</li><li>缺陷的复现步骤——复现缺陷的过程</li><li>缺陷的预期结果——希望得到的结果</li><li>缺陷的实际结果——实际得到的结果</li><li>缺陷的必要附件——图片、日志等信息</li></ul><h3 id="缺陷报告的其他要素"><a href="#缺陷报告的其他要素" class="headerlink" title="缺陷报告的其他要素"></a>缺陷报告的其他要素</h3><ul><li>缺陷的编号”能够唯一的表示一个缺陷</li><li>缺陷的状态：描述缺陷生命周期的过程<ul><li><strong>新建（new）</strong></li><li>打开（open）：表示开发确认通过</li><li>拒绝（rejected）：表示开发确认不通过</li><li>进行中（inprogress）：表示开发正在修复缺陷</li><li><strong>已修复（fixed）</strong>：回归测试</li><li>延迟修复（delay/postpone）</li><li><strong>测试通过（closed）</strong></li><li><strong>测试不通过（reopen/open）</strong></li></ul></li><li>缺陷的所属模块：描述缺陷产生的模块范围</li><li><strong>优先级：</strong>依据：1.测试用例优先级2.产品经理定的标准</li><li><strong>严重级</strong></li><li>缺陷的类型：<ul><li>功能问题</li><li>UI</li><li>兼容性</li><li>易用性</li><li>架构</li><li>安全性</li></ul></li></ul><h3 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h3><p>跟踪流程</p><h4 id="编写缺陷报告规范"><a href="#编写缺陷报告规范" class="headerlink" title="编写缺陷报告规范"></a>编写缺陷报告规范</h4><ul><li>可复现</li><li>唯一性</li><li>规范性：遵循公司规定的报bug的要求</li></ul><p>注意事项：</p><ul><li>确保上报的bug是准确的</li><li>描述尽可能简洁易懂</li><li>不能使用感情色彩的词语</li><li>不能使用模棱两可的词汇</li><li>不能使用人称代词</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>在实际测试中出现不可复现的bug怎么办？</p><pre class=" language-yacas"><code class="language-yacas">1.经过多次复现后，还是没有出现，此时在本地记录当前问题2.回顾当时操作的流程及测试环境的配置要求，确认是否是由于操作失误或环境临时故障引起3.请开发协助查找当前测试模块是否有对应的日志信息4.考虑更换一套环境查看是否能够复现上述问题5.在后续版本测试中，需要关注当时测试该功能时是否还出现上述的问题6.在后续版本还出现过，需要开发协助打印日志进行分析定位，同时测试需要提交bug</code></pre><h2 id="禅道"><a href="#禅道" class="headerlink" title="禅道"></a>禅道</h2><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>管理用例</p><ul><li>创建用例：将需求文档直接转换为可测试的功能点的过程</li><li>评审用例：查看已经编写好的用例是否有错误、遗漏、不正确的地方 进行评估的过程</li><li>执行用例</li></ul><p>管理缺陷</p><ul><li>缺陷的创建</li><li>缺陷的跟踪</li><li>缺陷的验证</li></ul><h2 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h2><p>基本测试策略：</p><ul><li>冒烟测试：基本功能检查、核心业务流程测试</li><li>单功能测试</li><li>集成测试与回归</li><li>系统测试与回归</li><li>验收测试与回归</li></ul><h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><p>概念：不同平台、系统都能正常工作</p><p>测试关注点（Web）：</p><ul><li>浏览器：IE、Chrome、FireFox</li><li>操作系统：Windows、Linux、mac等</li><li>网络</li><li>分辨率</li></ul><h3 id="界面测试"><a href="#界面测试" class="headerlink" title="界面测试"></a>界面测试</h3><p>测试用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件是否符合客户使用习惯</p><ul><li>布局</li><li>风格</li><li>按钮</li><li>测试基本原则：参照UI设计图</li><li>若无原型图：<ul><li>导航测试</li><li>图形测试</li><li>内容测试（有无错别字）</li><li>整体界面风格测试</li></ul></li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>易懂、易学</p><p>关注点：</p><ul><li>用户群体</li><li>计算机水平</li><li>项目复杂性</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>什么时候考虑：</p><ul><li>对性能有要求</li><li>用户量大</li></ul><p>目的：</p><p>验证稳定性、验证是否达到性能目标</p><p>并发测试、压力测试、负载测试</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>关注点：</p><p>输入数据：登录时密码是否进行加密以及密码是否容易破解，敏感信息遮挡处理，不能复制</p><p>传输数据：加密要有复杂度</p><p>输出数据：数据库中敏感信息要加密</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
            <tag> 功能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/Zzhanp.github.io/2021/11/03/ji-suan-ji-wang-luo-ti-xi-jie-gou/"/>
      <url>/Zzhanp.github.io/2021/11/03/ji-suan-ji-wang-luo-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><p>网络由若干结点和连接这些结点的链路组成。</p><p>internet（互联网或互联网）：通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</p><p>Internet（专有名词）：指全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，采用TCP/IP协议作为通信的规则，前身是美国的ARPANET。</p><h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><p> 单个网络ARPANET向互联网发展-&gt;逐步建成三级结构的因特网-&gt;逐步形成了多层次ISP结构的因特网</p><p>1969年，第一个分组交换网ARPANET。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>个人通过ISP接入到因特网</p><p>主干ISP：因特网主干网，直接互联</p><p>地区ISP：区域性或国家性覆盖规模</p><p>本地ISP：校园网、企业网、移动用户</p><p>相隔较远的两台主机通信：主机A-&gt;本地ISP-&gt;地区ISP-&gt; 主干ISP-&gt; 地区ISP-&gt;本地ISP-&gt;主机B</p><h3 id="因特网标准化工作"><a href="#因特网标准化工作" class="headerlink" title="因特网标准化工作"></a>因特网标准化工作</h3><p>RFC</p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p>边缘部分：由所有连接在因特网上的<strong>主机</strong>组成。用户直接使用，用来<strong>通信（传送数据、音频或视频）和资源共享</strong>。</p><p>核心部分：由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。为边缘部分提供服务（提供连通性和交换）。</p><h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>前提：所有电话机两两相连接不现实。</p><p>定义：电话交换机接通电话线的方式。</p><p>步骤：</p><ol><li>建立连接（分配通信资源）</li><li>通话（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ol><p>电路交换传送计算机数据时，线路传输效率低</p><h3 id="分组交换（重点）"><a href="#分组交换（重点）" class="headerlink" title="分组交换（重点）"></a>分组交换（重点）</h3><p>发送方：构造分组、发送分组</p><p>路由器：存储转发</p><p>接收方：接收分组、还原报文</p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>对报文大小无限制，交换结点需要有较大缓存空间，用于早期电报。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>分组交换：随时发送分组，不需要事先建立连接。分组在交换机进行存储转发，减少了转发时延，避免过长的报文长时间占用链路，同时有利于进行差错控制。</p><p>电路交换：比特流直达终点。</p><p>报文交换：报文需要在各节点交换机进行存储转发。</p><h4 id="电路交换优点"><a href="#电路交换优点" class="headerlink" title="电路交换优点"></a>电路交换优点</h4><ul><li>数据直达，通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广（既适用于传输数字信号，也可模拟信号）</li><li>实时性强</li><li>控制简单</li></ul><h4 id="电路交换缺点"><a href="#电路交换缺点" class="headerlink" title="电路交换缺点"></a>电路交换缺点</h4><ul><li>建立连接时间长</li><li>线路独占，使用效率低</li><li>灵活性差，任何一点出现故障，需要重新连接</li><li>难以规格化</li></ul><h4 id="报文交换优点"><a href="#报文交换优点" class="headerlink" title="报文交换优点"></a>报文交换优点</h4><ul><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性，某条路故障，选择另一条路</li><li>提高线路利用率</li><li>提供多目标服务，同时发给多个目标地址</li></ul><h4 id="报文交换缺点"><a href="#报文交换缺点" class="headerlink" title="报文交换缺点"></a>报文交换缺点</h4><ul><li>引起了转发时延</li><li>需要较大存储缓存空间</li><li>需要传输额外信息量</li></ul><h4 id="分组交换优点"><a href="#分组交换优点" class="headerlink" title="分组交换优点"></a>分组交换优点</h4><ul><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输，后一个的存储和前一个的转发可以同时进行</li><li>减少出错概率和重发数据量</li></ul><h4 id="分组交换缺点"><a href="#分组交换缺点" class="headerlink" title="分组交换缺点"></a>分组交换缺点</h4><ul><li>引起了转发时延</li><li>需要传输额外的信息量</li><li>对于数据报服务，存在丢序、丢失或重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程</li></ul><h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一些互相连接的、自治的计算机的集合</p><p>自治：独立的计算机，有自己的硬件和软件，可以单独运行使用。</p><p>计算机网络并非专门用来传输数据，而是能够支持很多种应用。</p><h3 id="分类（重点）"><a href="#分类（重点）" class="headerlink" title="分类（重点）"></a>分类（重点）</h3><h4 id="按交换技术"><a href="#按交换技术" class="headerlink" title="按交换技术"></a>按交换技术</h4><p>电路交换网络、报文交换网络、分组交换网络</p><h4 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h4><p>公用网、专用网</p><h4 id="按传输介质"><a href="#按传输介质" class="headerlink" title="按传输介质"></a>按传输介质</h4><p>有线网络、无线网络</p><h4 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h4><p><strong>广域网WAN</strong>：几十公里到几千公里，远程网。</p><p>城域网MAN：范围一个城市。</p><p><strong>局域网LAN</strong>：微型计算机或工作站通过高速通信线路相连（10Mb/s以上），校园网、企业网。</p><p><strong>个域网PAN</strong>：10米，个人设备用无线技术连起来的网络，无线个人区域网WPAN。</p><h4 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h4><p>总线型：</p><p>星型：成本高，中央设备对故障敏感</p><p>环型：单向传输</p><p>网状型：可靠性高，线路复杂、成本高</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>连接在计算机网络上的主机在数字信道上传送比特的速率，也称为<strong>比特率或数据率</strong>。</p><pre class=" language-yacas"><code class="language-yacas">比特，数据量的单位，1 Byte = 8 bit常用数据率单位：bit/s(b/s,bps)</code></pre><h3 id="带宽（重点）"><a href="#带宽（重点）" class="headerlink" title="带宽（重点）"></a>带宽（重点）</h3><p>表示网络的通信线路所能传送数据的能力，网络带宽表示在单位时间内从网络的某一点到另一点所能通过的<strong>“最高数据率”</strong>。单位b/s，如家里的网为200M，即200Mb/s。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>表示在<strong>单位时间内通过某个网络（或信道、接口）的数据量。受网络的带宽或额定速率的限制。</strong></p><h3 id="时延（重点）"><a href="#时延（重点）" class="headerlink" title="时延（重点）"></a>时延（重点）</h3><p>发送时延：源主机将分组发往传输线路，分组长度(b)/发送速率(b/s)，发送速率由网卡的发送速率、信道带宽、交换机的接口速率决定。</p><p>传播时延：电信号在链路传输，信道长度(m)/电磁波传播速率(m/s)，电磁波在铜线传播约为2.3x10^8 m/s，光纤约为2.0x10^8 m/s。</p><p>处理时延：路由器收到分组后对其进行存储转发。</p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><strong>指传播时延x带宽</strong>，以比特为单位的链路长度。</p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>RTT：卫星网络耗时较多</p><h3 id="利用率（重点）"><a href="#利用率（重点）" class="headerlink" title="利用率（重点）"></a>利用率（重点）</h3><p>信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过），并非越高越好。</p><p>网络利用率：全网络的信道利用率的加权平均</p><p>当网络的利用率达到50%时，时延就要加倍。D=D0/(1-U).</p><p>也不能使利用率太低，白白浪费通信资源。动态调整。</p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p>分组丢失率，<strong>丢失的分组数量与总分组数量的比率</strong>。</p><p>分组在传输过程中出现<strong>误码</strong>，被结点丢弃。</p><p>分组到达一台队列已满的分组交换机时被丢弃，在数据量较大时可能造成<strong>网络拥塞</strong>。</p><p>反映了网络的拥塞情况。</p><h2 id="计算机网络体系结构（重点）"><a href="#计算机网络体系结构（重点）" class="headerlink" title="计算机网络体系结构（重点）"></a>计算机网络体系结构（重点）</h2><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><h4 id="OSI体系结构"><a href="#OSI体系结构" class="headerlink" title="OSI体系结构"></a>OSI体系结构</h4><p>法律上的国际标准</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>失败原因：</p><p>1、OSI专家缺乏实际经验，OSI标准没有商业驱动力</p><p>2、OSI协议实现起来很复杂，且效率低</p><p>3、OSI标准制定周期太长，按OSI标准生产的设备无法及时进入市场</p><p>4、OSI层次划分不太合理，有些功能在多个层次重复出现</p><h4 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP/IP体系结构"></a>TCP/IP体系结构</h4><p>事实上的国际标准</p><ul><li>应用层：HTTP、SMTP、DNS、RTP</li><li>运输层：TCP、UDP</li><li>网际层：IP</li><li>网络接口层</li></ul><p>合并OSI物理层和数据链路层为网咯接口层，去掉了OSI的会话层和表示层。</p><p>路由器一般只包含网络接口层和网际层。</p><p>网络接口层并没有规定具体内容，因此TCP/IP只有上面三层。</p><p>使用IP协议互联不同的网络接口（IP over everything），同时可以为各种网络应用提供服务（everything over IP）。</p><h4 id="五层协议体系结构"><a href="#五层协议体系结构" class="headerlink" title="五层协议体系结构"></a>五层协议体系结构</h4><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>计算机网络是个非常复杂的系统</p><p>分层可将庞大而复杂的问题，转化为若干较小的局部问题。</p><p>物理层：解决使用何种信号来传输比特的问题</p><p>数据链路层：解决分组在一个网络（或一段链路）上传输的问题</p><p>网络层：解决分组在多个网络上传输（路由）的问题</p><p>运输层：解决进程之间基于网络的通信问题</p><p>应用层：解决通过应用进程的交互来实现特定网络应用的问题</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>实体：任何可发送或接收信息的硬件或软件进程。</p><p>协议：控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合。</p><p>协议的三要素：</p><p>语法：定义所交换信息的格式</p><p>语义：定义收发双方所要完成的操作</p><p>同步：定义收发双方的时序关系</p><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。</p><p>要实现本层协议，还需要使用下面一层所提供的服务。</p><p><strong>协议是水平的，服务是垂直的。</strong></p><p>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议，下面的协议对上面的实体是<strong>“透明”</strong>的。</p><p>协议数据单元PDU：<strong>对等层次之间传送的数据包</strong>称为该层的协议数据单元。</p><p>服务数据单元SDU：<strong>同一系统内，层与层之间交换的数据包</strong>称为服务数据单元。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1、在OSI参考模型中，自下而上第一个提供端到端服务的层次是：传输层</p><pre class=" language-yacas"><code class="language-yacas">传输层：解决进程之间基于网络的通信问题，提供端到端的逻辑通信传输层使用端口号为应用层的应用进程之间提供端到端的逻辑通信，而网络层仅仅为主机之间提供逻辑通信</code></pre><p>2、TCP/IP参考模型的网络层提供的是：无连接不可靠的数据报服务</p><p>3、在TCP/IP体系结构中，直接为ICMP提供服务的协议是：IP</p><p>4、在OSI参考模型中，下列功能需由应用层的相邻层实现的是：数据格式转换</p><p>5、时延：</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026202718538.png" alt="image-20211026202718538"></p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026211812041.png" alt="image-20211026211812041" style="zoom:150%;"></p><p><strong>n个发送时延+1个传播时延</strong></p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026212155919.png" alt="image-20211026212155919"></p><p><strong>n个分组，m段链路，总时延：</strong></p><ul><li><strong>n个分组的发送时延</strong></li><li><strong>1个分组的发送时延 x (m-1)</strong></li><li><strong>1段链路的传播时延 x m</strong></li></ul><p>6、</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026212517241.png" alt="image-20211026212517241"></p><p>7、</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20211026214322285.png" alt="image-20211026214322285"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/Zzhanp.github.io/2021/03/25/sql-zhu-ru/"/>
      <url>/Zzhanp.github.io/2021/03/25/sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入学习"><a href="#SQL注入学习" class="headerlink" title="SQL注入学习"></a>SQL注入学习</h1><p>接触安全这么久了，却连最基本的注入都还不会。。。令人汗颜。从这个笔记开始，好好学习注入，好好学习安全！本文借助sqli-labs来进行训练。</p><h2 id="联合查询注入过程"><a href="#联合查询注入过程" class="headerlink" title="联合查询注入过程"></a>联合查询注入过程</h2><p>1、判断注入点</p><p>2、判断是整型还是字符型</p><p>3、判断查询列数</p><p>4、判断显示位</p><p>5、获取所有数据库名</p><p>6、获取数据库所有表名</p><p>7、获取字段名</p><p>8、获取字段中的数据</p><p>常用闭合语句：</p><p>?id=1’#</p><p>?id=1#</p><p>?id=1’)#</p><p>?id=1’))#</p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>当输入的参数为字符串时，并且存在注入，可称为字符型注入，字符型和数值型的区别在于数值不需要单引号闭合，而字符型都需要单引号闭合。</strong></p><h3 id="判断整型还是字符型"><a href="#判断整型还是字符型" class="headerlink" title="判断整型还是字符型"></a>判断整型还是字符型</h3><p>数字型通常sql语句为：</p><p><code>select * from users where id =x</code></p><p>这种类型可以使用经典的and 1=1 and 1=2来判断</p><p>url地址中输入<code>www.xxxx.com/ccc.php?id=x and 1=1</code><br> 页面显示正常，继续下一步</p><p>url地址中输入<code>www.xxxx.com/ccc.php?id=x and 1=2</code><br> 页面错误，这说明存在数字型注入。</p><p>原因如下：<br> 当输入and 1=1时，后台会执行sql语句是：</p><p><code>select * from users where id =x and 1=1；</code></p><p>没有语法显示错误且，返回正常</p><p>当输入and 1=2时，后台会执行sql语句是：</p><p><code>select * from users where id =1 and 1=2;</code></p><p>也可以用id=2-1来判断</p><p>字符型：</p><h3 id="判断列数"><a href="#判断列数" class="headerlink" title="判断列数"></a>判断列数</h3><p>order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字 段名还可以指定字段的栏位进行排序，第一个查询字段为1，第二个为2，依次 类推。我们可以通过二分法来猜解列数。</p><p>输入 order by 4发现页面错误，说明没有4列。</p><p><code>http://127.0.0.1/sql/Less-1/?id=1&#39; order by 3 --+</code></p><h3 id="判断显示位"><a href="#判断显示位" class="headerlink" title="判断显示位"></a>判断显示位</h3><h4 id="显示位"><a href="#显示位" class="headerlink" title="显示位"></a>显示位</h4><p>我们在进行手工SQL注入的时候会用到ORDER BY 查询列数，然后通过UNION SELECT爆出在网页中的显示位。这个显示位指的是网页中能够显示数据的位置。举例来说，比如我们通过ORDER BY命令知道了表的列数为11。然后再使用UNION SELECT 1,2,3…,11 from table，网页中显示了信息8，那么说明网页只能够显示第8列中信息，不能显示其他列的信息。也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。所以如果我们想要知道某个属性的值，比如admin,就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。</p><h4 id="UNION查询"><a href="#UNION查询" class="headerlink" title="UNION查询"></a>UNION查询</h4><p>UNION的作用是将两个select查询结果合并，只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了。</p><p><code>http://127.0.0.1/sql/Less-1/?id=861&#39; union select 1,2,3 --+</code></p><h3 id="判断所有数据库名"><a href="#判断所有数据库名" class="headerlink" title="判断所有数据库名"></a>判断所有数据库名</h3><p>select schema_name from information_schema.schemata </p><p>information_schema,这是系统数据库，安装完成就会有，它记录着所有数据库，表，列，用户权限等，下面再说一下常用的几个表：</p><p>SCHEMATA表</p><p>储存着mysql所有的数据库信息，show databases的结果就是取自这个表。</p><p>TABLES表</p><p>储存的数据库所有的表信息，表是基本表还是系统表，创建时间，数据库的引擎是什么，表有多少行等，show tables from mysql的结果就是取自这个表。</p><p>Columns表</p><p>储存这数据库所有的列信息，show columns from mysql.user的结果就是取自这个表</p><p>这里还要说一点，group_concat函数可以显示出所有查询的所有数据，limit只显示某一行。</p><p>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</p><p>显示当前数据库： databas()</p><p><code>http://127.0.0.1/sql/Less-1/?id=-1&#39; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+</code></p><h3 id="猜某库的数据表"><a href="#猜某库的数据表" class="headerlink" title="猜某库的数据表"></a>猜某库的数据表</h3><p>select table_name from information_schema.tables where table_schema=’xxxxx’ </p><p><code>http://127.0.0.1/sql/Less-1/?id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),3 --+</code></p><h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><p><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;</code></p><h3 id="获取用户名密码"><a href="#获取用户名密码" class="headerlink" title="获取用户名密码"></a>获取用户名密码</h3><p><code>http://127.0.0.1/sql/Less-1/?id=-1&#39; union select 1,(select group_concat(username) from security.users),3 --+</code></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> SQL </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习</title>
      <link href="/Zzhanp.github.io/2021/03/25/sql-xue-xi/"/>
      <url>/Zzhanp.github.io/2021/03/25/sql-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL学习"><a href="#SQL学习" class="headerlink" title="SQL学习"></a>SQL学习</h1><h2 id="mysql创建数据库"><a href="#mysql创建数据库" class="headerlink" title="mysql创建数据库"></a>mysql创建数据库</h2><p>用create命令创建数据库：</p><p><code>CREATE DATABASE 数据库名;</code></p><h2 id="mysql删除数据库"><a href="#mysql删除数据库" class="headerlink" title="mysql删除数据库"></a>mysql删除数据库</h2><p>用drop命令删除数据库：</p><p><code>drop database &lt;数据库名&gt;;</code></p><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p>通用语法：</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE table_name (column_name column_type);</code></pre><h2 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h2><pre class=" language-mysql"><code class="language-mysql">DROP TABLE table_name;</code></pre><p>例：</p><pre class=" language-mysql"><code class="language-mysql">root@host# mysql -u root -pEnter password:*******mysql> use RUNOOB;Database changedmysql> DROP TABLE runoob_tblQuery OK, 0 rows affected (0.8 sec)mysql></code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>使用INSERT INTO 语句来插入数据，语法如下：</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO table_name ( field1, field2,...fieldN )                       VALUES                       ( value1, value2,...valueN );</code></pre><p>如果数据是字符型，必须使用单引号或双引号，如”value”。</p><pre class=" language-mysql"><code class="language-mysql">mysql> INSERT INTO runoob_tbl     -> (runoob_title, runoob_author, submission_date)    -> VALUES    -> ("学习 PHP", "菜鸟教程", NOW());</code></pre><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>使用SELECT语句来查询数据，语法如下：</p><pre class=" language-mysql"><code class="language-mysql">SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M]</code></pre><ul><li><p>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</p></li><li><p>SELECT 命令可以读取一条或者多条记录。</p></li><li><p>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</p></li><li><p>你可以使用 WHERE 语句来包含任何条件。</p></li><li><p>你可以使用 LIMIT 属性来设定返回的记录数。</p></li><li><p>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</p></li><li><p>例：</p><pre class=" language-mysql"><code class="language-mysql">select * from runoob_tbl;</code></pre></li></ul><h2 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h2><p>查询数据使用SQL SELECT语句，若要有条件地选取数据，可将WHERE子句添加到SELECT语句中。</p><pre class=" language-mysql"><code class="language-mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2.....</code></pre><ul><li>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li></ul><h2 id="UPDATE更新"><a href="#UPDATE更新" class="headerlink" title="UPDATE更新"></a>UPDATE更新</h2><p>如果需要修改或更新mysql中的数据，可以用SQL UPDATE命令：</p><pre class=" language-mysql"><code class="language-mysql">UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause]</code></pre><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p>例：</p><pre class=" language-mysql"><code class="language-mysql">mysql> UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3; Query OK, 1 rows affected (0.01 sec)  mysql> SELECT * from runoob_tbl WHERE runoob_id=3; +-----------+--------------+---------------+---------------+ | runoob_id | runoob_title | runoob_author | submission_date +-----------+--------------+---------------+---------------+ | 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      | +-----------+--------------+---------------+---------------+ 1 rows in set (0.01 sec)</code></pre><h2 id="UNION查询"><a href="#UNION查询" class="headerlink" title="UNION查询"></a>UNION查询</h2><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。语法如下：</p><pre class=" language-mysql"><code class="language-mysql">SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions];</code></pre><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables:</strong> 要检索的数据表。</li><li><strong>WHERE conditions:</strong> 可选， 检索条件。</li><li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全学习</title>
      <link href="/Zzhanp.github.io/2021/03/05/web-an-quan-xue-xi/"/>
      <url>/Zzhanp.github.io/2021/03/05/web-an-quan-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Web安全学习"><a href="#Web安全学习" class="headerlink" title="Web安全学习"></a>Web安全学习</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP(HyperText Transfer Protocol)即超文本传输协议，它允许将HTML文档从Web服务器传送到Web浏览器。</p><p>URL：统一资源定位符，即网页地址。标准格式：</p><p><strong>协议://服务器IP[:端口]/路径/[?查询]，如<a href="http://www.xxser.com/post/httpxieyi.html" target="_blank" rel="noopener">http://www.xxser.com/post/httpxieyi.html</a></strong></p><p>Windows中，可以用curl.exe工具，通过curl+URL命令即可发起一个HTTP请求。</p><p>HTTP是一种无状态的协议。当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。<strong>HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据。</strong></p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p><code>GET / HTTP/1.1</code>                     <!--请求行--><br><code>Host: www.baidu.com</code>          <!--请求头--><br><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0</code></p><p>请求行由说明该请求是GET请求，使用的是HTTP1.1版本。</p><p>请求头中，HOST代表请求的主机地址，User-Agent代表浏览器的标识。</p><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>GET：GET方法用于获取请求页面的指定信息。</p><p>HEAD：HEAD方法除了服务器不能在响应里返回消息主体外，其他都与FET方法相同。</p><p>POST：向服务器传输大量的数据，通常使用POST请求。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>1xx：信息提示，标识请求已被成功接收，继续处理，其范围为100~101.</p><p>2xx：成功，服务器成功地处理了请求，范围为200~206.</p><p>3xx：重定向，用于告诉浏览器客户端，他们访问的资源已被移动，并告诉客户端新的资源地址位置。</p><p>4xx：客户端错误状态码，有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求，或者最常见的是，请求一个不存在的URL。</p><p>5xx：描述服务器内部错误。</p><p><strong>常见状态码：</strong></p><p>200：客户端请求成功，是最常见的状态。</p><p>302：重定向。</p><p>404：请求资源不存在。</p><p>400：客户端请求有语法错误，不能被服务器所理解。</p><p>401：请求未经授权。</p><p>403：服务器收到请求，但是拒绝提供服务。</p><p>500：服务器内部错误，是最常见的状态。</p><p>503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p><h3 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a>HTTP消息</h3><p>又称HTTP头（HTTP header），由请求头、响应头、普通头和实体头组成。</p><p><strong>请求头：</strong></p><p>请求头只出现在HTTP请求中，常用的HTTP请求头如下：</p><p>Host：指定被请求资源的Internet主机和端口号。</p><p>User-Agent：允许客户端将它的操作系统、浏览器和其他属性告诉服务器。</p><p>Referer：Referer包含一个URL，代表当前访问URL的上一个URL。如：Referer:<a href="http://www.xxser.com/login.php，代表用户从login.php来到当前页面。" target="_blank" rel="noopener">www.xxser.com/login.php，代表用户从login.php来到当前页面。</a></p><p>Cookie：它是一段文本，常用来表示请求者身份。</p><p>Range：可以请求实体的部分内容，多线程下载一定会用到此请求头。</p><p>x-forward-for：即XFF头，他代表请求端的IP，可以有多个，中间以逗号隔开。</p><p>Accept：用于指定客户端接收哪些MIME类型的消息，如Accept：text/html，表明客户端希望接收HTML文本。</p><p><strong>响应头：</strong></p><p>Server：服务器所使用的Web服务器名称，如Server:Apache/1.3.6(Unix)，攻击者通过查看此头，可以探测Web服务器名称。</p><p>Set-Cookie：向客户端设置Cookie，通过查看此头，可以清楚地看到服务器向客户端发送的Cookie信息。</p><p>Lsat-Modified：服务器通过这个头告诉浏览器，资源的最后修改时间。</p><p>Location：告诉浏览器去访问哪个页面，浏览器收到此请求后，通常会立刻访问Location头所指向地页面。这个头通常配合302状态码使用.</p><p>Refresh：告诉浏览器定时刷新浏览器。</p><h3 id="HTTP协议与HTTPS协议的区别"><a href="#HTTP协议与HTTPS协议的区别" class="headerlink" title="HTTP协议与HTTPS协议的区别"></a>HTTP协议与HTTPS协议的区别</h3><p>HTTPS：Hyper Text Transfer Protocol over SecureSocket Layer，是以安全为目标地HTTP通道。</p><p>HTTPS地安全基础是SSL 。</p><p>HTTP 是超文本传输协议，信息是明文传输，HTTPS则是具有安全性地SSL加密传输协议。</p><p>HTTP采用80端口连接，HTTP是443端口。</p><p>HTTPS协议需要到ca申请证书。</p><h2 id="信息探测"><a href="#信息探测" class="headerlink" title="信息探测"></a>信息探测</h2><h3 id="Google-Hack"><a href="#Google-Hack" class="headerlink" title="Google Hack"></a>Google Hack</h3><h4 id="搜集Web信息"><a href="#搜集Web信息" class="headerlink" title="搜集Web信息"></a>搜集Web信息</h4><p>site：指定域名</p><p>intext：正文中存在关键字地网页</p><p>intitle：标题中存在关键字地网页</p><p>info：一些基本信息</p><p>inurl：URL存在关键字地网页</p><p>filetype：搜索指定文件类型</p><p>例：intitle:管理登录 filetype:php：查询网页标题含有“管理登录”，并且为php类型地网页。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/Zzhanp.github.io/2021/03/02/php/"/>
      <url>/Zzhanp.github.io/2021/03/02/php/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP学习"><a href="#PHP学习" class="headerlink" title="PHP学习"></a>PHP学习</h1><h2 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a><strong>搭建环境</strong></h3><p><strong>静态网站访问流程：</strong></p><p>本地DNS和网络DNS，先经过本地DNS寻找，再去网络DNS寻找。</p><p>/index.heml：URI（Identifier）统一资源标识，目标机器上相对某个文件夹的相对路径。</p><p>Apache根据URI获取文件，读取文件内容。</p><p><strong>动态网站访问流程：</strong></p><p>与静态差不多，但多出几个内容：<strong>服务器端解析、数据库</strong>。</p><p><strong>Apache目录结构：</strong></p><p>bin：windows下的一些可执行文件</p><p>conf：配置文件目录</p><p>htdocs：Apache默认的主机地址</p><p>凡是涉及到Apache配置文件的修改，需要重启Apache才能生效。</p><p><strong>PHP目录结构：</strong></p><p>ext：扩展包，PHP很多功能是通过加载扩展来实现。</p><p>PHP.exe：PHP解释器</p><h3 id="PHP语法基础"><a href="#PHP语法基础" class="headerlink" title="PHP语法基础"></a><strong>PHP语法基础</strong></h3><p><strong>php代码标记：</strong>&lt;?php php代码?&gt;</p><p><strong>php注释：</strong></p><p>行注释：//或#</p><p>块注释：一次注释多行</p><p>/<em> xxxxxx</em>/</p><p><strong>php语句分隔符：</strong>分号“;”（英文状态）</p><p>特殊说明：</p><p>1、PHP中标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符“;”。</p><p>2、PHP中很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中不建议使用标记结束符?&gt;</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><p><strong>定义变量：</strong>php中不需要任何关键字定义变量，所有变量必须使用“$”。</p><p><code>$var1;</code></p><p><code>$var2 = 1;</code></p><p><strong>访问变量：</strong>echo $var2; //通过var2变量名字找到存储内容1，然后输出。</p><p><strong>删除变量：</strong>使用unset，unset($var2)</p><p><strong>变量命名规则：</strong>由字母、数字和下划线构成，不能以数字开头。</p><p><strong>预定义变量：</strong><code>$_GET,$_POST,$_REQUEST,$_COOKIE,$_SERVER</code>等。</p><p>$_GET:获取所有表单以get方式提交的数据。</p><p>变量传值：将一个变量赋值给另外一个变量</p><p>值传递：讲变量保存的值复制一份，然后将新的值给另外一个变量保存。</p><p>引用传递：将变量保存的值所在的内存地址，传递给另一个变量，两个变量指向同一块内存空间。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安实验室之MISC</title>
      <link href="/Zzhanp.github.io/2020/07/11/xin-an-shi-yan-shi-zhi-misc/"/>
      <url>/Zzhanp.github.io/2020/07/11/xin-an-shi-yan-shi-zhi-misc/</url>
      
        <content type="html"><![CDATA[<h1 id="信安实验室之MISC"><a href="#信安实验室之MISC" class="headerlink" title="信安实验室之MISC"></a>信安实验室之MISC</h1><p>本以为进不去实验室了，没想到老天眷顾，给了我这次机会，那便好好努力吧！</p><h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h2><p>签到题，给了一串字符</p><p>ZmxhZ3tXZTFjMG1lX3QwX0IxVF9OU0MhfQ==</p><p>Base64加密，解密即可得</p><p>flag{We1c0me_t0_B1T_NSC!}</p><p><strong>这里想说的是后面有俩等号的都是base64加密</strong></p><h2 id="PDF-1"><a href="#PDF-1" class="headerlink" title="PDF_1"></a>PDF_1</h2><p>第一次遇到pdf的题，打开看到是一张图片，一开始我还想着把pdf改成jpg或png呢。。。太傻了简直。。</p><p>猜想flag隐藏在图片下方，如何移开图片呢？</p><p>1.利用在线工具：<a href="https://app.xunjiepdf.com/pdf2word" target="_blank" rel="noopener">https://app.xunjiepdf.com/pdf2word</a> 将pdf转换为word，从而移开图片</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/ctf2.png" alt="ctf2" style="zoom: 50%;"></p><p>可以看到左上角有一行flag</p><p>2.apowerpdf 本地工具打开pdf,将照片移开得到flag</p><p>3.用Linux自带工具pdftotext将pdf转为txt</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/ctf1.png" alt="ctf1"></p><p>转为txt后，用grep查找flag或者直接打开txt来查找</p><h2 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h2><p>给了一个数独，并提示：flag：第一行和最后一行连接形成的字符串，再经过MD5转换，取32位大写</p><p>emm然而我并不会解数独。。。不过还好有万能的百度</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/ctf3.png" alt="ctf3" style="zoom:67%;"></p><p>第一行加最后一行是267381945895143267</p><p>MD5转换得：ae382493d0b370d6959d8b44ab128bda</p><p>转换大写即可flag{AE382493D0B370D6959D8B44AB128BDA}</p><h2 id="DIO-1"><a href="#DIO-1" class="headerlink" title="DIO_1"></a>DIO_1</h2>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> misc </tag>
            
            <tag> 信安实验室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku-web-wp</title>
      <link href="/Zzhanp.github.io/2020/05/10/bugku-web-wp/"/>
      <url>/Zzhanp.github.io/2020/05/10/bugku-web-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="bugku-web"><a href="#bugku-web" class="headerlink" title="bugku-web"></a>bugku-web</h1><p>最近学校的ctf比赛开始了，但是尝试了一下，几乎一道都做不出来。。。</p><p>唉。。还是稳扎稳打，一步一步来吧</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>F12查看源代码</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200510173650240.png" alt=""></p><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>这道题是让你输个验证码，但是输的时候发现只能输一位数字。</p><p>F12，修改验证框的大小</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200510181926711.png" alt="image-20200510181926711"></p><p>1修改为10，之后就能输的下啦~</p><p>点击验证，得到flag{CTF-bugku-0032}</p><h2 id="web基础-GET"><a href="#web基础-GET" class="headerlink" title="web基础$_GET"></a>web基础$_GET</h2><p><code>$what=$_GET[&#39;what&#39;];//读取参数what，把值存到变量what中 echo $what;//输出 if($what==&#39;flag&#39;)//如果值为flag echo &#39;flag{****}&#39;;//打印flag</code></p><p>因此，地址修改为<code>http://123.206.87.240:8002/get/?what=flag</code></p><p><u>这里要注意，get请求，传入参数的形式是在url后面加 <strong>?参数=值</strong></u></p><p><u>多个参数用<strong>?参数1=值1&amp;参数2=值2……</strong></u></p><h2 id="web基础-POST"><a href="#web基础-POST" class="headerlink" title="web基础$_POST"></a>web基础$_POST</h2><p>题目和上一道类似，考察基础</p><p><code>$what=$_POST[&#39;what&#39;];//接受post过来的参数what，存到what里 echo $what;//打印 if($what==&#39;flag&#39;)//如果值是flag echo &#39;flag{****}&#39;;//打印flag</code></p><p>注意，POST请求没法写在url里，需要用hackbar或者burp修改，格式是在</p><p><strong>参数1=值&amp;参数2=值</strong></p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/post.png" alt="post"></p><p>之后得到</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200510182951888.png" alt=""></p><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>看题</p><p><code>$num=$_GET[&#39;num&#39;];//获取参数num if(!is_numeric($num))//如果不是数字 { echo $num;//打印 if($num==1)//如果是数字且为1 echo &#39;flag{**********}&#39;;打印flag }</code></p><p>搜索一下 is_numeric() 函数：</p><p><strong>用于检测变量是否为数字或数字字符串</strong></p><p> 这个要求不是数字且为1，有点矛盾是不是？其实有绕过的办法。下面num==1的判定是两个等号，这是弱类型比较，如果等号两边类型不同，会转换成相同类型再比较。与之对应的是强类型比较，用的是三个等号===，如果类型不同就直接不相等了。<strong>在弱类型比较下，当一个字符串与数字比较时，会把字符串转换成数字，具体是保留字母前的数字。例如123ab7c会转成123，ab7c会转成0.（字母前没数字就是0）</strong></p><p>所以payload：</p><p><code>http://123.206.87.240:8002/get/index1.php?num=1a</code></p><p>得1aflag{bugku-789-ps-ssdf}</p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>打开页面后有个弹窗，点击阻止加载</p><p>F12查看原码</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200510214748579.png" alt="image-20200510214748579"></p><p>发现下面有一串字</p><p><code>&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125;</code></p><p>是一串Unicode码，打开转换工具，转成ASCII码即可得到flag</p><p>&#75;&#69;&#89;&#123;&#74;&#50;&#115;&#97;&#52;&#50;&#97;&#104;&#74;&#75;&#45;&#72;&#83;&#49;&#49;&#73;&#73;&#73;&#125;</p><p>惊奇的发现，typora中Unicode居然能自动转为ASCII码。。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>题目是让把  flag.baidu.com  解析到123.206.87.240</p><p>打开电脑的host文件，添加解析规则</p><p>C:\Windows\System32\drivers\etc</p><p>添加  123.206.87.240 flag.baidu.com</p><p>之后再访问flag.baidu.com即可得到flag</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200510215629963.png" alt="image-20200510215629963"></p><p>学习一下host文件：</p><p><strong>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</strong></p><h2 id="你必须让他停下"><a href="#你必须让他停下" class="headerlink" title="你必须让他停下"></a>你必须让他停下</h2>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugku </tag>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku之misc</title>
      <link href="/Zzhanp.github.io/2020/05/01/bugku-zhi-misc/"/>
      <url>/Zzhanp.github.io/2020/05/01/bugku-zhi-misc/</url>
      
        <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>学校的题没有解析。。好多不太会做，于是重拾bugku，从bugku开始我的ctf之旅吧~</p><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><p>emm<br>懂的都懂</p><h3 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h3><p>看题~<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/525_1.png" alt="525_1"><br>给了一张图片，FLAG在哪里？<br>根据提示，考虑图片隐写<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/527_1.jpg" alt="527_1"><br>查看属性<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/529_1.png" alt="529_1"><br>没有什么异常~<br>用010查看<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/531_1.png" alt="531_1"><br>发现最下端有一段Unicode编码<br>复制 解码<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/533_1.png" alt="533_1"><br>over~<br><strong>思考：因为看学长做了一遍，所以知道做法。我想知道怎样判断考的是这种Unicode编码还是那种改长和宽的？？？<br>另外，要学习一下怎样看那个png的编码，哪里是长、哪里是宽！</strong></p><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><p>看题~ 给了一张图片<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/537_1.png" alt="537_1" style="zoom:80%;"><br>根据现有的经验<br>png文件 查看属性<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/539_1.png" alt="539_1"><br>高和宽不对等<br>尝试改变高度 0420 换成16进制是01A4<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/541_1.png" alt="541_1"><br>如图 将A4改为F4<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/543_1.png" alt="543_1"><br>保存<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/545_1.png" alt="545_1" style="zoom:67%;"><br>果然最下面出现了flag~</p><p><strong>这里总结一下：图片隐写类，png文件要看看高宽是否相等<br>png的数据头是89504E47</strong><br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/547_1.png" alt="547_1"></p><p><strong>jpg文件 开始标志 FF D8  结束标志 FF D9</strong><br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/549_1.png" alt="549_1"><br><strong>png文件的第二行八个字节表示宽和高<br>前四位是宽 后四位是高</strong></p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/551_1.png" alt="551_1"><br>给了一个zip包<br>下载解压<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/553_1.png" alt="553_1"><br>发现居然能用wireshark打开（幸好之前下载过）<br>百度了一下telnet<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/555_1.png" alt="555_1"><br>看到熟悉的TCP/IP 与wireshark有关也不奇怪了</p><h3 id="啊哒"><a href="#啊哒" class="headerlink" title="啊哒"></a>啊哒</h3><p>看题<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/557_1.png" alt="557_1"><br>解压 是一张jpg图片<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/559_1.jpg" alt="559_1" style="zoom:50%;"><br>由于先前的经验（之前一道jpg的题是文件最后藏了一串Unicode编码）<br>于是 拖进010查看<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/561_1.png" alt="561_1"><br>果然 在最后发现了 flag.txt<br>说明这个图片里藏着一个txt文件<br>这里有一个强大的工具 <strong>binwalk</strong><br>是<strong>查看下载的文件中是否包含其他文件</strong>的神器，正好与本题需求契合</p><p>打开kali 将图片拖进去 binwalk分析一番<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/563_1.png" alt="563_1"><br>果然里面藏着一个flag.txt<br>接下来的任务就是把这个txt文件提取出来<br>分离文件的方法有很多，如binwalk、foremost、dd等<br>这里采用foremost<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/565_1.png" alt="565_1"><br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/567_1.png" alt="567_1"><br>成功分离~<br>但是这里发现此文件需要密码</p><p>但是过程中并没有什么密码。。<br>回头重新查看图片<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/569_1.png" alt="569_1"><br>发现这里有一串奇怪的数字<br>十六进制解码一下得到一个像解压密码的东西<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/571_1.png" alt="571_1"><br>试一下~<br><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/573_1.png" alt="573_1"><br>成功~</p><p><strong>总结：这道题挺有意思的，学到的也挺多</strong></p><h4 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a>分离文件</h4><p>binwalk：<strong>多重文件查看利器</strong><br>在CTF的<strong>MISC类题型和IOT安全的固件解包分析</strong>中广泛应用</p><p><strong>binwalk的主要功能：</strong></p><h5 id="扫描固件"><a href="#扫描固件" class="headerlink" title="扫描固件"></a>扫描固件</h5><p>Binwalk可以扫描许多不同嵌入式文件类型和文件系统的固件映像，只需给它一个要扫描的文件列表<br>binwalk xxxx.xxx（文件名）</p><h5 id="文件提取（-e-–extract）"><a href="#文件提取（-e-–extract）" class="headerlink" title="文件提取（-e,–extract）"></a>文件提取（-e,–extract）</h5><p>可以使用-e选项提取它在固件映像中找到的任何文件。</p><pre><code>binwalk -e firmware.bin</code></pre><p><strong>foremost</strong></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugku </tag>
            
            <tag> ctf </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署后没有新文章</title>
      <link href="/Zzhanp.github.io/2020/04/30/bu-shu-hou-mei-you-xin-wen-zhang/"/>
      <url>/Zzhanp.github.io/2020/04/30/bu-shu-hou-mei-you-xin-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>今天写了一篇新博客，一波操作上传后发现博客里并没有那篇新文章。。</p><p>找了一下public文件夹里也没有那篇。。</p><p>搜索也没搜出来什么。。</p><p>最后对比了一下，发现这篇新文章tags后面少了个空格。。。。。。</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200430141520766.png" alt="image-20200430141520766"></p><p>汗(lll￢ω￢)。。。以此为戒吧。。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给博客设置图床(PicGo+腾讯云)</title>
      <link href="/Zzhanp.github.io/2020/04/30/gei-bo-ke-she-zhi-tu-chuang-picgo-jia-teng-xun-yun/"/>
      <url>/Zzhanp.github.io/2020/04/30/gei-bo-ke-she-zhi-tu-chuang-picgo-jia-teng-xun-yun/</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo-腾讯云COS设置图床"><a href="#PicGo-腾讯云COS设置图床" class="headerlink" title="PicGo+腾讯云COS设置图床"></a>PicGo+腾讯云COS设置图床</h1><p>写博客不配图片实在是没有趣味。。。</p><p>记得以前配过七牛云的，但是最近打开博客发现全都失效了：原因是七牛云设置的测试域名，有效期只有30天，而若用自己的域名的话，还要去备案，而我又没有服务器。。。</p><p>找来找去，发现了腾讯云+PicGo的方法。</p><p>首先</p><h4 id="1-注册腾讯云及创建对象存储"><a href="#1-注册腾讯云及创建对象存储" class="headerlink" title="1.注册腾讯云及创建对象存储"></a>1.注册腾讯云及创建对象存储</h4><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200430134037678.png" style="zoom:67%;"></p><p>首先，创建存储桶。需要注意的是，访问权限一定要填<strong>公有读私有写</strong></p><h4 id="2-配置腾讯云密钥"><a href="#2-配置腾讯云密钥" class="headerlink" title="2.配置腾讯云密钥"></a>2.配置腾讯云密钥</h4><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/image-20200430134355633.png" alt=""></p><p>点击 新建密钥，复制SecretId和SecretKey</p><h4 id="3-下载PicGo并设置图床"><a href="#3-下载PicGo并设置图床" class="headerlink" title="3.下载PicGo并设置图床"></a>3.下载PicGo并设置图床</h4><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/peizhi.png" alt=""></p><p>把刚才复制的东西依次填入，这里需要注意，cos版本要选到v5，刚开始没注意，默认在v4，结果后来无论怎样都上传失败。。。最后把调到v5就可以了~</p><p>美中不足的是，这个腾讯云的免费存储只有6个月。不过暂时也够用了，到期了再说吧。。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传博客时遇到的问题</title>
      <link href="/Zzhanp.github.io/2020/04/29/shang-chuan-bo-ke-shi-yu-dao-de-wen-ti/"/>
      <url>/Zzhanp.github.io/2020/04/29/shang-chuan-bo-ke-shi-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>好久没有玩博客了，域名也到期了。今天心血来潮，又买了个新域名，搞了好久。</p><p>终于能打开博客了，但发现主题还是旧的。想到我新配置的文件还没有上传，但是上传时出现了问题。</p><p><code>fatal: Could not read from remote repository.</code></p><p><code>Please make sure you have the correct access rights</code><br><code>and the repository exists.</code></p><p>首先查了一下第二个错误：</p><p>网上说是ssh文件没有配置好，输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>验证一下，又出现了</p><p><code>Error: git@github.com: Permission denied (publickey)</code></p><p>再搜索一下，还是在说ssh的事情。。。打开GitHub发现我的SSH key里居然什么都没有。。</p><p>遂到 <strong>C:\用户\lenovo\ .ssh</strong>中找到了id_rsa和id_rsa.pub两个文件</p><p>把id_rsa.pub中的代码复制到GitHub里</p><p>开心的想着，这下应该可以了吧~</p><p>然后<code>$ ssh git@github.com</code></p><p><code>Hi Zzhanp! You&#39;ve successfully authenticated, but GitHub does not provide shellaccess.</code></p><p>晕。。这啥意思啊。。有个not。。感觉又失败了。。</p><p>搜索一下：有的说</p><!--这种方式比较简单粗暴，直接将`GitHub`的`ssh key`删除掉，然后重新生成一份新的。--><p>有的说 没关系，这就是成功了</p><p>因为我懒。。所以我愿意相信第二种说法。。</p><p>然后hexo d，出现了</p><figcaption>You must verify your email address.</figcaption><pre class=" language-ERROR:"><code class="language-ERROR:">See https://github.com/settings/emails.</code></pre><p>emm，我只是想上传个博客。。</p><p>再搜索。。说应该是我的邮箱失效了</p><p>登上GitHub一看果然：</p><p><img src="https://zzhanp-1257986342.cos.ap-beijing.myqcloud.com/img/email.png" alt=""></p><p>上网搜了一下，让再整一个qq邮箱来验证，照做。</p><p>又看到什么改完邮箱以后还要重新配置一下。。。</p><p>好麻烦。。懒惰的我，死马当活马医，又试了一下hexo d</p><p>没想到居然成功了。。。</p><p>总之。。今天的事情我也不知道问题出在哪里。。记录一下以防万一吧。。。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假学习计划</title>
      <link href="/Zzhanp.github.io/2019/01/19/han-jia-xue-xi-ji-hua/"/>
      <url>/Zzhanp.github.io/2019/01/19/han-jia-xue-xi-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>1.Python（大创学习任务）</p><p>2.51单片机（最好能到点阵LED）</p><p>3.arduino（完成俱乐部任务）</p><p>4.学有余力：Linux视频</p><p>加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019计划</title>
      <link href="/Zzhanp.github.io/2019/01/13/2019-ji-hua/"/>
      <url>/Zzhanp.github.io/2019/01/13/2019-ji-hua/</url>
      
        <content type="html"><![CDATA[<p><strong>19年打卡~~</strong></p><ul><li><p>[ ] 1.去一趟故宫，在故宫看一场初雪~（希望老天配合）</p></li><li><p>[ ] 2.在景山公园看一次日出~</p></li><li><p>[ ] 3.在香山看一次日落~</p></li><li><p>[ ] 4.去雍和宫上一炷香</p></li><li><p>[ ] 5.看一场德云社的相声</p></li><li><p>[ ] 6.去三联通宵看一页的书~</p></li><li><p>[x] 7.去簋街吃好吃哒~</p></li><li style="list-style: none"><input type="checkbox"> 8.读20本书（<strong>要包括英文书</strong>）</li><li style="list-style: none"><input type="checkbox"> 9.学会python和单片机</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019</title>
      <link href="/Zzhanp.github.io/2018/12/31/2019/"/>
      <url>/Zzhanp.github.io/2018/12/31/2019/</url>
      
        <content type="html"><![CDATA[<p>2019年，新的一年，加油！努力做那个更好的自己！</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 所思所想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等值数列段</title>
      <link href="/Zzhanp.github.io/2018/11/21/deng-zhi-shu-lie-duan/"/>
      <url>/Zzhanp.github.io/2018/11/21/deng-zhi-shu-lie-duan/</url>
      
        <content type="html"><![CDATA[<p>这几天做C语言作业时遇到一道挺有意思的题（其实是自己被难到了），决定在这里好好理一下自己的思路~</p><p><strong>题目描述：</strong></p><p>如果一个数列中的某一段（至少有两个元素）的各元素值均相同，则称之为等值数列段。等值数列段中元素的个数叫做等值数列段的长度。</p><p><strong>输入：</strong>        由N个元素组成的整数数列A（其中N&lt;=50)</p><p><strong>输出：</strong>        A中长度最大的所有等值数列段的始末位置，如果没有等值数列段，则输出No equal number list.</p><p><strong>说明：</strong>        始末位置是指数组下标，即0表示第一个元素。<br>​        如果有多个同等长度的等值数列，只输出第一个等值数列的起始位置。即：当在一个LIST中出现两个等长的连续串时，答案应该是第一个等长串。</p><p><strong>思路：</strong></p><p>这道题有几个难点：一是如何让计算机找出重复的数列；二是如何数数列的长度；三是如何找出最长的数列。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疑难问题 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub打不开解决方案</title>
      <link href="/Zzhanp.github.io/2018/11/08/github-da-bu-kai-jie-jue-fang-an/"/>
      <url>/Zzhanp.github.io/2018/11/08/github-da-bu-kai-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p><strong>GitHub打不开的解决方案</strong></p><p><img src="http://pi0d6q266.bkt.clouddn.com/a.png" alt="image"></p><p>解决这个问题的方法是 更改hosts文件，地址：C:\Windows\System32\Drivers\etc</p><p>在文章的末尾添加：</p><p>#github</p><p>192.30.253.112 github.com <!--这里的一串数字是你的ip地址，具体查看方式在下方--></p><p>151.101.185.194 github.global.ssl.fastly.net</p><p>此时你可能会遇到权限不足问题，会提示你是否以管理员的身份编辑，点确定即可</p><p>下面是<strong>查找的github的网址</strong>：</p><p><a href="http://github.com.ipaddress.com/" target="_blank" rel="noopener">http://github.com.ipaddress.com/</a></p><p><strong>查找域名github.global.ssl.fastly.net：网址</strong>：（<a href="http://github.global.ssl.fastly.net.ipaddress.com/）" target="_blank" rel="noopener">http://github.global.ssl.fastly.net.ipaddress.com/）</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学期学习计划</title>
      <link href="/Zzhanp.github.io/2018/11/08/ben-xue-qi-xue-xi-ji-hua/"/>
      <url>/Zzhanp.github.io/2018/11/08/ben-xue-qi-xue-xi-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>课程之外：<br><strong>1.本学期要学完Python</strong>（为大创做准备）<br>2.51单片机（掌握）<br>3.Arduino（了解）<br>课程之内：<br>1.工科数学分析（多做题）<br>2.线性代数（习题册）<br>3.C语言（积极完成作业）</p><p>tip:本学期要加油鸭！大学的第一个学期，不能懒惰！<br>要多更新博客！</p>]]></content>
      
      
      <categories>
          
          <category> 学习计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
